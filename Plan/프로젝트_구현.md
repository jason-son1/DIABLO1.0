__데이터 기반 마인크래프트 RPG 엔진 아키텍처 및 디아블로 IV 시스템 구현에 관한 심층 기술 보고서__

__1. 서론: 차세대 데이터 주도형(Data-Driven) RPG 서버의 비전__

현대 게임 개발, 특히 대규모 멀티플레이어 온라인(MMO) 환경 구축에 있어 가장 혁신적인 패러다임은 '데이터 주도형 설계(Data-Driven Design)'입니다. 사용자가 제시한 비전인 "노트북(Notebook) 데이터를 기반으로 한 독자적인 마인크래프트 RPG 서버"는 단순히 기존의 플러그인을 조합하는 수준을 넘어, 게임의 규칙과 콘텐츠를 코드(Code)가 아닌 데이터(Data)로 정의하는 엔터프라이즈급 아키텍처를 요구합니다. 본 보고서는 디아블로 IV(Diablo IV)의 정교한 시스템—특히 파라곤 보드(Paragon Board), 글리프(Glyph), 그리고 속성(Attribute) 시스템—을 심층 분석하여, 이를 마인크래프트 환경에서 완벽하게 재현하고 확장할 수 있는 기술적 청사진을 제시합니다.

이 프로젝트의 핵심은 **유연성(Flexibility)**과 **확장성(Scalability)**입니다. 기존의 하드코딩된 시스템은 게임 밸런스를 조정하거나 새로운 콘텐츠를 추가할 때마다 서버를 재시작하거나 코드를 수정해야 하는 비효율성을 내포하고 있습니다. 그러나 본 보고서에서 제안하는 시스템은 외부의 데이터 소스(Excel, JSON, Jupyter Notebook 등)를 단일 진실 공급원(Single Source of Truth, SSOT)으로 삼아, 기획자가 데이터를 수정하면 서버가 이를 실시간으로 반영하여 게임 월드를 변화시키는 구조를 갖습니다. 이를 실현하기 위해 MythicMobs, ModelEngine과 같은 검증된 미들웨어를 API 레벨에서 통합하고, Fabric 기반의 클라이언트 모드를 통해 서버 주도형 UI(Server-Driven UI)를 구현하며, 최신 AI 기술인 모델 컨텍스트 프로토콜(MCP)을 도입하여 개발 파이프라인을 자동화하는 구체적인 방법론을 논합니다.<sup>1</sup>


---

__2. 디아블로 IV 시스템의 구조적 분석 및 데이터 추상화__

디아블로 IV의 시스템은 표면적으로는 복잡해 보이지만, 내부적으로는 정교한 수학적 그래프와 태그 시스템으로 구성되어 있습니다. 이를 마인크래프트 서버의 '노트북 데이터'로 치환하기 위해서는 각 컴포넌트의 데이터 구조를 명확히 분해하고 재조립해야 합니다.

__2.1 파라곤 보드(Paragon Board) 시스템의 그래프 이론적 접근__

디아블로 IV의 엔드게임 성장을 담당하는 파라곤 보드는 단순한 스킬 트리가 아니라, 회전하고 연결 가능한 **방향성 비순환 그래프(Directed Acyclic Graph, DAG)**의 형태를 띱니다.<sup>4</sup> 사용자의 요구대로 세부 설정을 자유롭게 바꿀 수 있는 독자적인 시스템을 만들기 위해서는, 이 보드 시스템을 유동적인 데이터 객체로 모델링해야 합니다.

__2.1.1 노드(Node) 및 보드(Board)의 데이터 구조화__

기존의 정적인 스킬 트리와 달리, 파라곤 보드는 '게이트(Gate)' 노드를 통해 새로운 보드를 연결하고 회전시킬 수 있습니다. 이를 구현하기 위해 서버는 각 보드를 2차원 격자(Grid) 데이터로 관리하지 않고, 노드 간의 연결성(Edge)을 정의한 그래프 객체로 관리해야 합니다.


<table>
  <tr>
   <td><strong>데이터 필드 (JSON Schema)</strong>
   </td>
   <td><strong>설명</strong>
   </td>
   <td><strong>데이터 타입</strong>
   </td>
   <td><strong>비고</strong>
   </td>
  </tr>
  <tr>
   <td>board_id
   </td>
   <td>보드의 고유 식별자 (예: Sorcerer_Fire_01)
   </td>
   <td>String
   </td>
   <td>외부 노트북 데이터의 Key
   </td>
  </tr>
  <tr>
   <td>nodes
   </td>
   <td>보드에 포함된 노드 목록
   </td>
   <td>Map&lt;ID, Node>
   </td>
   <td>좌표 및 타입 정보 포함
   </td>
  </tr>
  <tr>
   <td>gates
   </td>
   <td>다른 보드와 연결 가능한 접점 노드
   </td>
   <td>List
   </td>
   <td>보드 회전 시 좌표 변환 필요
   </td>
  </tr>
  <tr>
   <td>glyph_sockets
   </td>
   <td>글리프 장착 슬롯
   </td>
   <td>List
   </td>
   <td>반경 계산의 기준점
   </td>
  </tr>
</table>


이 구조에서 핵심은 __좌표계의 추상화__입니다. 보드가 회전(0도, 90도, 180도, 270도)할 때마다 노드의 절대 좌표가 변경되므로, 서버는 '로컬 좌표(Local Coordinate)'와 '월드 좌표(World Coordinate)'를 분리하여 연산해야 합니다. 노트북 데이터에서는 로컬 좌표만을 정의하며, 플레이어가 보드를 연결하는 순간 서버는 회전 값을 적용하여 월드 좌표로 변환, 클라이언트에 전송합니다.<sup>6</sup>

__2.1.2 글리프(Glyph)와 반경 연산 알고리즘__

글리프 시스템은 특정 소켓 주변의 노드들을 강화하는 매커니즘을 가집니다. 이를 구현하기 위해 서버는 실시간으로 공간 쿼리(Spatial Query)를 수행해야 합니다. 디아블로 IV 데이터마이닝 결과에 따르면, 글리프의 범위는 타일 단위의 거리(Manhattan Distance 또는 Chebyshev Distance)가 아닌, 유클리드 거리(Euclidean Distance)에 가까운 독자적인 로직을 따릅니다.<sup>8</sup>

최적화를 위해, 글리프의 영향권 계산은 **옵저버 패턴(Observer Pattern)**을 활용합니다.



1. __Subject (글리프 소켓):__ 글리프가 장착되거나 레벨업하여 반경이 변경되면 이벤트를 발행합니다.
2. Observer (주변 노드): 소켓 주변의 노드들은 자신을 구독(Subscribe)하고 있다가, 이벤트 발생 시 자신의 능력치(예: 지능 +5 → 지능 +7)를 재계산합니다. \
 이 방식은 매 프레임마다 거리를 계산하는 오버헤드를 제거하여, 수천 개의 노드가 활성화된 상태에서도 서버 틱(Tick) 저하를 방지합니다.

__2.2 속성(Attribute) 시스템과 데미지 버킷(Damage Bucket)__

디아블로 IV의 데미지 계산식은 여러 개의 '버킷(Bucket)'으로 나뉘어 곱연산되는 구조를 가집니다.<sup>10</sup> 마인크래프트의 단순한 공격력 시스템을 이를 대체하기 위해, __속성 컨테이너(Attribute Container)__ 아키텍처를 도입해야 합니다.

__2.2.1 동적 속성 파이프라인 설계__

노트북 데이터에서 Fire_Damage_Bonus, Vulnerable_Damage, Crit_Chance 등 임의의 스탯을 추가하더라도 코드 수정 없이 작동하도록, 속성 시스템은 Map&lt;String, Double> 형태의 유동적인 구조를 가져야 합니다.



* __기본 스탯 (Base Stats):__ 힘, 민첩, 지능, 의지력 (노트북에서 정의된 기본값)
* __합연산 그룹 (Additive Bucket):__ [+]로 표시되는 모든 데미지 증가 옵션. (예: "불타는 적에게 주는 피해 +20%", "근거리 피해 +10%")
* __곱연산 그룹 (Multiplicative Bucket):__ [x]로 표시되는 독립적인 증폭 옵션. (예: "전설 노드: 화염 피해 1.5배")
* __조건부 트리거 (Conditional Triggers):__ 상태 이상(취약, 보강, 제압)에 따른 동적 계산.

이를 Java 코드로 구현할 때, 각 데미지 이벤트는 DamageContext 객체를 생성하고, 이 객체가 플레이어의 AttributeContainer를 순회하며 최종 데미지를 산출합니다. <sup>12</sup>에 따르면, 이러한 연산은 매우 빈번하게 발생하므로, 결과값을 캐싱(Caching)하고 스탯 변경 시에만 캐시를 무효화(Invalidate)하는 전략이 필수적입니다.


---

__3. 데이터 주도형(Data-Driven) 서버 아키텍처__

사용자가 강조한 "노트북 데이터 기반"이라는 요구사항은 이 서버의 핵심 정체성입니다. 이는 게임의 모든 밸런스와 설정이 컴파일된 JAR 파일이 아닌, 외부 데이터 파일(Excel, JSON, Database)에 의해 결정됨을 의미합니다.

__3.1 데이터 수집 및 변환 파이프라인 (The Notebook Pipeline)__

기획자나 관리자가 Jupyter Notebook, Excel, 또는 구글 스프레드시트에서 데이터를 수정하면, 서버는 이를 즉시 게임 내 객체로 변환해야 합니다.

__3.1.1 ETL (Extract, Transform, Load) 프로세스 구축__



1. __Extract (추출):__ 서버는 시작 시, 또는 /reload_data 명령어 입력 시 지정된 데이터 소스(CSV 파일 경로 또는 웹 API)로부터 원시 데이터를 로드합니다.
2. __Transform (변환):__ 로드된 데이터는 유효성 검사(Validation)를 거칩니다. 예를 들어, 파라곤 노드가 존재하지 않는 속성을 참조하거나, 연결될 수 없는 위치에 있는 경우 오류를 리포트합니다. 이 과정에서 텍스트 데이터("Fireball Skill")는 내부 ID(skill_fireball_01)로 매핑됩니다.
3. __Load (적재):__ 검증된 데이터는 메모리 상의 DataManager에 캐싱됩니다. 기존의 마인크래프트 서버들이 사용하는 YAML 파싱 방식은 대용량 데이터 처리에 느리고 유연성이 떨어지므로, __Gson__이나 __Jackson__ 라이브러리를 사용한 스트리밍 파싱 방식을 채택합니다.<sup>14</sup>

__3.2 엔티티 컴포넌트 시스템 (ECS) 도입__

전통적인 객체 지향 프로그래밍(OOP)에서 Zombie 클래스는 Monster를 상속받지만, 디아블로 스타일의 다양한 속성을 부여하기에는 경직되어 있습니다. 따라서, 마인크래프트 엔티티 위에 가상의 __ECS(Entity Component System)__ 레이어를 구축합니다.<sup>2</sup>



* __Entity:__ 마인크래프트의 LivingEntity (UUID).
* __Component:__ 데이터의 집합.
* ParagonComponent: 파라곤 보드 상태 데이터.
* StatsComponent: 현재 계산된 모든 속성 값.
* SkillComponent: 활성화된 스킬 및 쿨타임 정보.
* __System:__ 로직의 집합.
* DamageSystem: 공격 이벤트 발생 시 StatsComponent를 참조하여 데미지 계산.
* RegenSystem: 매 틱마다 StatsComponent의 재생력을 참조하여 체력 회복.

이 구조를 통해, 노트북 데이터에서 "이 몬스터는 파라곤 시스템을 사용한다"라고 정의하기만 하면, 해당 몬스터에게 ParagonComponent가 부착되어 즉시 관련 로직이 적용되는 유연성을 확보할 수 있습니다.


---

__4. 서버-클라이언트 통신 및 네트워크 프로토콜__

디아블로 IV와 같은 복잡한 UI와 실시간 수치 변화를 표현하기 위해서는 마인크래프트의 기본 패킷 시스템만으로는 부족합니다. 서버(Spigot)와 클라이언트(Fabric) 간의 전용 고속 통신 채널이 필요합니다.

__4.1 전용 채널 및 패킷 직렬화 전략__

마인크래프트의 Plugin Message Channel은 최대 크기 제한(약 32KB~2MB)이 있으며, 대용량 데이터를 메인 스레드에서 처리할 경우 치명적인 랙(Lag)을 유발합니다.<sup>16</sup> 이를 극복하기 위해 __Netty__ 기반의 커스텀 패킷 핸들링과 효율적인 직렬화(Serialization) 기술이 요구됩니다.

__4.1.1 프로토콜 버퍼(Protobuf) vs 플랫버퍼(FlatBuffers)__

연구 결과에 따르면, 대용량의 파라곤 보드 데이터와 빈번한 스탯 업데이트를 처리하기 위해 JSON은 부적합합니다.



* __Protocol Buffers (Protobuf):__ 데이터 크기가 작고, 스키마 관리가 용이합니다. 빈번한 작은 업데이트(예: 스탯 변경, 아이템 획득)에 적합합니다.<sup>18</sup>
* __FlatBuffers:__ "Zero-Copy" 접근이 가능하여, 데이터를 파싱(Parsing)하는 과정 없이 즉시 읽을 수 있습니다. 수천 개의 노드 정보를 포함하는 초기 접속 시의 대용량 데이터 전송(Bulk Sync)에 탁월한 성능을 발휘합니다.<sup>20</sup>

__최종 기술 스택:__ 하이브리드 접근 방식을 채택합니다.



* __초기 동기화 (Login/World Change):__ __FlatBuffers__를 사용하여 전체 파라곤 보드와 스킬 트리 구조를 압축 전송합니다.
* __실시간 업데이트 (Combat/Interaction):__ __Protobuf__를 사용하여 빠르고 가벼운 패킷(노드 클릭, 스탯 갱신)을 처리합니다.

__4.2 서버 주도형 UI (Server-Driven UI, SDUI) 프로토콜__

클라이언트 모드(Fabric)를 단순히 데이터를 보여주는 '뷰어(Viewer)'로 만들고, 모든 UI의 배치와 구성을 서버에서 제어하는 __Server-Driven UI__ 아키텍처를 구현합니다.<sup>21</sup>

__4.2.1 JSON 기반 UI 정의 프로토콜__

서버는 클라이언트에게 다음과 같은 JSON 패킷을 전송하여 UI를 그립니다. 클라이언트는 이 JSON을 해석하여 네이티브 GUI 요소로 렌더링합니다.

 

JSON

 

{ \
   "packet_type": "open_window", \
   "window_id": "paragon_main", \
   "layout": { \
     "type": "scroll_panel", \
     "background": "texture:rpg/paragon_bg", \
     "children": [ \
       { \
         "type": "node_graph", \
         "data_source": "user_paragon_data", \
         "interaction_event": "click_node" \
       } \
     ] \
   } \
 } \
 \
 \


이 방식의 장점은 클라이언트 모드 업데이트 없이도, 서버 쪽의 노트북 데이터 수정만으로 UI의 레이아웃, 색상, 텍스트, 아이콘 등을 변경할 수 있다는 점입니다. Fabric 클라이언트에서는 __Owo-Lib__ 또는 __ModernUI__ 라이브러리를 활용하여 이러한 동적 UI 렌더링 시스템을 구축합니다.<sup>23</sup>


---

__5. 외부 플러그인 API 통합 및 커스터마이징__

MythicMobs와 ModelEngine은 강력한 툴이지만, 기본적으로 YAML 파일 기반의 정적 설정을 사용합니다. 데이터 주도형 서버를 위해서는 이들의 내부 API를 후킹(Hooking)하여 런타임에 데이터를 주입해야 합니다.

__5.1 MythicMobs의 프로그래매틱(Programmatic) 생성__

MythicMobs는 API를 통해 런타임에 몹을 등록하는 기능을 제한적으로 제공합니다. 그러나 노트북 데이터를 실시간으로 반영하기 위해서는 __가상 파일 주입(Virtual File Injection)__ 또는 **리플렉션(Reflection)**을 활용한 직접 등록 방식이 필요합니다.<sup>25</sup>

__5.1.1 동적 몹 팩토리 (Dynamic Mob Factory)__



1. __데이터 로드:__ 노트북에서 "Boss_Fire_Demon"의 데이터를 읽어옵니다. (체력: 500,000, 스킬: Fireball).
2. __객체 생성:__ 서버 메모리 내에서 MythicMob 객체를 생성하고, 노트북의 데이터를 기반으로 MythicMob.setHealth(), MythicMob.addSkill() 메서드를 호출하여 속성을 설정합니다.
3. __등록 및 스폰:__ 생성된 객체를 MobManager에 등록하고, 월드에 스폰시킵니다. 이 과정은 파일 I/O 없이 메모리 상에서만 이루어지므로 매우 빠릅니다.

__5.2 ModelEngine과 동적 본(Bone) 제어__

ModelEngine(ME)은 3D 모델을 엔티티에 입히는 역할을 합니다. 사용자의 요구인 "세부적인 데이터와 설정을 자유롭게" 하기 위해서는, 모델의 애니메이션과 파츠(Parts)도 데이터에 따라 변해야 합니다.

__5.2.1 런타임 본 변형 (Runtime Bone Transformation)__

ModelEngine API의 ActiveModel과 ModelBone 인터페이스를 활용합니다.<sup>27</sup>



* __상태 기반 외형 변화:__ 몬스터의 체력이 50% 이하로 떨어지면(노트북 설정 데이터), 서버는 해당 엔티티의 ActiveModel에 접근하여 arm_left 본(Bone)을 제거하거나 텍스처를 '손상된 갑옷'으로 교체하는 패킷을 보냅니다.
* __애니메이션 동기화:__ RPG 엔진에서 계산된 '공격 속도' 스탯을 ModelEngine의 애니메이션 속도 파라미터(Lerp 값 또는 Speed Multiplier)에 실시간으로 반영하여, 수치적 성능과 시각적 연출을 일치시킵니다.


---

__6. 데이터 처리 최적화 및 저장소 전략__

방대한 파라곤 데이터와 유저 로그를 처리하기 위해서는 단일 데이터베이스로는 한계가 있습니다. **데이터베이스 샤딩(Sharding)**과 __계층형 캐싱(Tiered Caching)__ 전략이 필수적입니다.

__6.1 UUID 기반 샤딩 (Sharding) 전략__

플레이어 데이터의 폭증을 대비하여, 단일 MySQL 서버 대신 여러 개의 데이터베이스 인스턴스로 부하를 분산합니다.<sup>29</sup>



* __샤딩 알고리즘:__ Shard_ID = Player_UUID.hashCode() % Total_Shards
* __구현:__ 플레이어가 접속하면, 프록시(또는 로그인 서버)는 UUID를 해싱하여 해당 플레이어의 데이터가 저장된 DB 샤드(Shard 0 ~ Shard N)를 결정하고 연결합니다. 이는 특정 DB에 장애가 발생하더라도 전체 서버가 마비되는 것을 방지합니다.

__6.2 Redis를 활용한 Write-Through 캐싱__

고빈도 데이터(체력, 마나, 현재 위치, 쿨타임)는 디스크 기반의 DB에 직접 기록하기에는 너무 빠릅니다. 따라서 인메모리 데이터베이스인 __Redis__를 활용합니다.<sup>31</sup>



* __Write-Through 패턴:__ 데이터 변경 시 Redis에 먼저 기록하고, 비동기적으로 DB에 백업합니다.
* __TTL(Time-To-Live) 전략:__ 접속 중인 플레이어 데이터는 만료되지 않게 유지하되, 로그아웃 시 10분의 TTL을 설정하여 재접속 시 빠르게 로드되도록 합니다.
* __Thundering Herd 방지:__ 서버 재시작 시 수천 명의 데이터가 동시에 만료되어 DB를 강타하는 것을 막기 위해, TTL에 무작위 지터(Jitter, ±30초)를 추가하여 만료 시점을 분산시킵니다.<sup>33</sup>


---

__7. AI Agent 기반 개발 시스템 (MCP & RAG)__

사용자가 요청한 "AI Agent 기반 개발 시스템"은 단순한 코드 생성을 넘어, 서버 운영과 개발을 보조하는 지능형 파트너를 구축하는 것입니다. 이를 위해 최신 **Model Context Protocol (MCP)**과 __검색 증강 생성(RAG)__ 기술을 도입합니다.

__7.1 MCP (Model Context Protocol) 서버 구축__

MCP는 AI 모델(Claude, GPT-4)이 외부 도구와 데이터에 안전하게 접근할 수 있게 하는 표준 프로토콜입니다.<sup>34</sup> 우리는 마인크래프트 서버를 위한 전용 MCP 서버를 Java로 구현합니다.

__7.1.1 MCP 서버의 기능__

이 MCP 서버는 개발 환경의 LLM(Cursor, Windsurf 등)과 마인크래프트 서버 사이를 중계합니다.



* __리소스 접근:__ AI가 현재 서버의 plugin.yml, config.json, 그리고 "노트북 데이터"를 직접 읽고 분석할 수 있습니다.
* __도구(Tool) 실행:__ AI에게 다음과 같은 권한을 부여합니다.
* reload_plugin(): 코드 수정 후 플러그인 리로드.
* validate_data(): 노트북 데이터의 무결성 검사.
* generate_mob_yaml(): 데이터에 기반한 MythicMobs 설정 파일 생성.

__7.2 RAG (Retrieval-Augmented Generation) 파이프라인__

MythicMobs나 Fabric API와 같은 라이브러리는 업데이트가 잦아 AI의 학습 데이터가 구식일 수 있습니다. 이를 해결하기 위해 문서 기반의 RAG 시스템을 구축합니다.<sup>37</sup>



1. __지식 베이스 구축:__ 최신 MythicMobs 위키, ModelEngine Javadocs, Fabric API 문서를 크롤링하여 벡터 데이터베이스(Pinecone, ChromaDB)에 저장합니다.
2. __컨텍스트 주입:__ AI가 코드를 작성할 때, RAG 시스템이 관련 API 문서를 검색하여 프롬프트에 주입합니다. (예: "MythicMobs 5.6버전의 스킬 문법을 참고하여 코드를 작성해.")
3. __자동화된 코딩:__ 개발자가 "노트북의 3번 시트에 있는 보스 데이터를 구현해줘"라고 요청하면, AI는 노트북 데이터를 읽고, RAG를 통해 최신 문법을 확인한 뒤, 완벽한 설정 파일이나 Java 코드를 생성하여 서버에 적용합니다.


---

__8. 결론 및 구현 로드맵__

본 보고서는 노트북 데이터를 핵심 동력으로 삼아 디아블로 IV의 깊이 있는 시스템을 마인크래프트에 이식하는 거대한 아키텍처를 설계하였습니다.



1. __Phase 1 (인프라):__ Spigot-Fabric 간의 Netty 기반 커스텀 패킷 채널(FlatBuffers) 구축 및 Redis/MySQL 샤딩 환경 조성.
2. __Phase 2 (데이터 엔진):__ 노트북 데이터(JSON/CSV) 파서 및 ECS(Entity Component System) 기반의 속성/스탯 엔진 구현.
3. __Phase 3 (콘텐츠 통합):__ MythicMobs 및 ModelEngine API 후킹을 통한 동적 몹/모델 생성 시스템 개발.
4. __Phase 4 (AI 파이프라인):__ MCP 서버 및 RAG 기반의 자동화 개발 환경 구축, 데이터 무결성 검증 자동화.
5. __Phase 5 (클라이언트 UI):__ Owo-Lib을 활용한 서버 주도형(Server-Driven) 파라곤/스킬 UI 렌더링 구현.

이 시스템은 정적인 마인크래프트 서버의 한계를 뛰어넘어, 데이터와 AI가 주도하는 살아있는 게임 엔진으로서 기능할 것입니다. 독자적인 게임성을 확보하면서도 운영의 효율성을 극대화할 수 있는 가장 진보된 형태의 서버 아키텍처입니다.


<table>
  <tr>
   <td><strong>항목</strong>
   </td>
   <td><strong>기존 방식</strong>
   </td>
   <td><strong>제안된 방식 (Data-Driven & AI)</strong>
   </td>
  </tr>
  <tr>
   <td><strong>콘텐츠 정의</strong>
   </td>
   <td>YAML 파일 수동 편집
   </td>
   <td>외부 노트북(Excel/JSON) 데이터 자동 로드
   </td>
  </tr>
  <tr>
   <td><strong>성장 시스템</strong>
   </td>
   <td>단순 레벨업/스탯
   </td>
   <td>디아블로 IV 파라곤 보드 (그래프/노드 기반)
   </td>
  </tr>
  <tr>
   <td><strong>네트워킹</strong>
   </td>
   <td>기본 Plugin Message (무거움)
   </td>
   <td>FlatBuffers/Protobuf 기반 고속 커스텀 패킷
   </td>
  </tr>
  <tr>
   <td><strong>UI 구현</strong>
   </td>
   <td>클라이언트 모드 하드코딩
   </td>
   <td>서버 주도형 UI (JSON 프로토콜)
   </td>
  </tr>
  <tr>
   <td><strong>개발 방식</strong>
   </td>
   <td>수동 코딩 및 설정
   </td>
   <td>MCP/RAG 기반 AI 에이전트 자동 생성
   </td>
  </tr>
  <tr>
   <td><strong>확장성</strong>
   </td>
   <td>단일 DB 의존
   </td>
   <td>UUID 샤딩 및 Redis 계층형 캐싱
   </td>
  </tr>
</table>


이 계획안은 기술적 난이도가 높지만, 구현 성공 시 타의 추종을 불허하는 독보적인 퀄리티와 운영 편의성을 제공할 것입니다.


             \
 \
__ __추가 

 \
 __프로젝트 생크추어리: LuaSkript 기반 동적 개발 환경 및 데이터 파이프라인 명세서__

__문서 번호:__ PS-TECH-002 __관련 문서:__ 프로젝트_계획_구현.docx, 프로젝트_계획_전투.docx __작성 목적:__ Excel/JSON/Protobuf로 정의된 정적 데이터를 LuaSkript 엔진을 통해 동적 게임 로직으로 변환하는 하이브리드 아키텍처 설계

__1. 아키텍처 개요: 3계층 하이브리드 엔진 (The 3-Tier Hybrid Engine)__

본 프로젝트는 성능(Java), 생산성(Lua), 데이터 무결성(Protobuf/Excel)을 모두 확보하기 위해 다음과 같은 3계층 구조를 채택한다. 이 구조의 핵심은 **"자바는 실행하고, 데이터는 정의하며, 루아는 연결한다"**는 원칙이다.

__1.1 계층 구조도__



1. __데이터 계층 (Data Layer - Static Definition)__
    * __형식:__ Excel, CSV, JSON, FlatBuffers, Protobuf
    * __역할:__ 몬스터 스탯, 아이템 기본 속성, 스킬 계수, 드롭 테이블 등 __"변하지 않는 수치"__ 정의.
    * __도구:__ 기획자는 엑셀이나 Jupyter Notebook에서 작업 후 바이너리/JSON으로 익스포트.
2. __스크립트 계층 (Logic Layer - LuaSkript)__
    * __형식:__ .lua 스크립트 파일
    * __역할:__ 데이터 계층의 수치를 읽어와 실제 **"행동(Behavior)"**을 정의.
    * __특징:__ 서버 재시작 없이 Hot-Reload 가능. onCast, onHit, onEquip 등의 이벤트 트리거 처리.
3. __엔진 계층 (Core Layer - Java/Spigot)__
    * __형식:__ Java Plugins (Paper/Purpur)
    * __역할:__ 고성능 연산(네트워킹, 패킷 처리, 멀티스레딩), Lua 샌드박스 구동, 데이터 파싱.
    * __라이브러리:__ Luaj 또는 LuaJIT 바인딩 사용.

__2. 데이터 파이프라인: 정적 데이터의 흐름 (Data Ingestion)__

기획자가 정의한 데이터를 LuaSkript에서 객체(Object)처럼 사용할 수 있도록 변환하는 과정이다.

__2.1 데이터 정의 (Schema Definition)__



* __Protobuf/FlatBuffers 스키마 예시 (skill.proto):__
* message SkillData {
*   string id = 1;
*   string name = 2;
*   float damage_coefficient = 3;
*   repeated string tags = 4; // ["Fire", "Projectile"]
*   map&lt;string, float> custom_params = 5; // 유연한 확장성
* }

__2.2 자바 엔진의 역할 (Loader & Binder)__



1. __로드:__ 서버 시작 시 또는 /reload logic 명령 시 .bin (Protobuf) 또는 .json 파일을 자바 메모리로 로드한다.
2. __바인딩 (Binding):__ 자바 객체(POJO)를 Lua의 Userdata 또는 Table 형태로 매핑하여 Lua 환경에 주입한다.
    * _Java:_ luaGlobals.set("SkillDB", new LuaTable(parsedSkillDataMap));

__3. LuaSkript 시스템 구현: 모듈별 개발 환경__

개발자는 LuaSkript를 사용하여 직업, 스킬, 아이템 등의 로직을 다음과 같이 구현한다.

__3.1 전투 시스템 (Combat System) 구현__

디아블로 IV의 복잡한 __데미지 버킷(Damage Buckets)__ 공식을 Lua 함수로 구현하여, 기획자가 공식을 언제든 수정할 수 있게 한다.



* __데이터 소스:__ damage_formulas.xlsx -> formulas.json
* __LuaSkript 구현 예시:__
* -- Combat.lua
* -- 엔진에 의해 호출되는 메인 데미지 계산 함수
* function calculate_damage(attacker, victim, skill_id)
*     -- 1. 데이터 계층에서 스킬 정보 가져오기 (Protobuf 데이터)
*     local skill_data = Data.SkillDB:get(skill_id)
*  
*     -- 2. 자바 엔진 API를 통해 스탯 가져오기
*     local base_dmg = attacker:getStat("WEAPON_DAMAGE")
*     local main_stat = attacker:getStat("DEXTERITY") -- 혼령사 예시
*  
*     -- 3. 데미지 버킷 연산 (시즌 6 공식 적용)
*     local bucket_additive = attacker:getAdditiveDamageSum(victim) -- 합연산
*     local bucket_multi = attacker:getMultipliers() -- 곱연산
*  
*     -- 4. 로직 적용
*     local total_dmg = base_dmg * (1 + main_stat * 0.001) * (1 + bucket_additive) * bucket_multi * skill_data.damage_coefficient
*  
*     -- 5. 크리티컬 및 취약 처리 (고정 배율 적용)
*     if Combat:rollCrit(attacker) then
*         total_dmg = total_dmg * 1.5
*     end
*  
*     return total_dmg
* end

__3.2 스킬 및 직업 메커니즘 (Class & Skill)__

혼령사의 '혼령 전당'이나 원소술사의 '인챈트 슬롯' 같은 복잡한 메커니즘을 스크립트로 제어한다.



* __데이터 소스:__ class_mechanics.json (태그 정보, 쿨타임 등)
* __LuaSkript 구현 예시:__
* -- Spiritborn_Jaguar.lua
* -- 스킬 시전 시 발동되는 이벤트 리스너
* function onCast(caster, skill_id)
*     local skill_data = Data.SkillDB:get(skill_id)
*  
*     -- 데이터에 정의된 태그 확인 (Excel에서 정의됨)
*     if skill_data:hasTag("JAGUAR") then
*         -- 혼령 전당 메커니즘: 15회 타격 시 추가 데미지
*         local stacks = caster:getVar("jaguar_stacks") or 0
*         stacks = stacks + 1
*  
*         if stacks >= 15 then
*         	local recent_dmg = caster:getVar("recent_damage_pool")
*         	Combat:dealDamage(caster, caster:getTarget(), recent_dmg * 0.15)
*             caster:sendActionBar("§c[Jaguar] Ferocity Unleashed!")
*         	stacks = 0
*         end
*  
*         caster:setVar("jaguar_stacks", stacks)
*     end
* end

__3.3 아이템 시스템 (Itemization)__

담금질(Tempering)과 명품화(Masterworking) 로직을 Lua로 처리하여 실패 확률이나 옵션 부여 로직을 유동적으로 관리한다.



* __데이터 소스:__ tempering_manuals.flatbuffer (매뉴얼 종류, 확률 분포)
* __LuaSkript 구현 예시:__
* -- Blacksmith.lua
* function onTempering(player, item, manual_id)
*     -- 1. 데이터 로드
*     local manual = Data.TemperingDB:get(manual_id)
*     local item_durability = item:getNBT("temper_durability")
*  
*     -- 2. 실패(벽돌) 로직
*     if item_durability &lt;= 0 then
*         player:sendMessage("§c더 이상 담금질할 수 없습니다.")
*         return false
*     end
*  
*     -- 3. 확률 기반 옵션 추첨 (데이터에 정의된 가중치 사용)
*     local selected_affix = Math:weightedRandom(manual.affixes)
*     local roll_value = Math:random(selected_affix.min, selected_affix.max)
*  
*     -- 4. 아이템 NBT 업데이트 (자바 엔진 호출)
*     item:addStat(selected_affix.stat_type, roll_value)
*     item:setNBT("temper_durability", item_durability - 1)
*  
*     player:playSound("BLOCK_ANVIL_USE")
*     return true
* end

__3.4 몬스터 AI 및 패턴 (Monster & Boss)__

MythicMobs의 한계를 넘어선 절차적 패턴이나 복잡한 상태 머신(State Machine)을 구현한다.



* __데이터 소스:__ boss_patterns.yaml (패턴 발동 조건, 데미지 계수)
* __LuaSkript 구현 예시:__
* -- Boss_Andariel.lua
* function onTick(boss)
*     local hp_percent = boss:getHealthPercent()
*  
*     -- 2페이즈 전환 (데이터 기반 임계값)
*     if hp_percent &lt; Data.BossDB.Andariel.phase_2_threshold then
*         if not boss:hasTag("Phase2") then
*             boss:addTag("Phase2")
*             boss:playAnimation("modelengine:andariel_scream")
*  
*         	-- 주변 플레이어에게 독 장판 생성 스크립트 실행
*         	local players = boss:getNearbyPlayers(20)
*         	for _, p in pairs(players) do
*                 Skill:cast("PoisonNova", boss, p:getLocation())
*         	end
*         end
*     end
* end

__4. 개발 워크플로우 (Development Workflow)__

이 시스템을 사용하는 개발팀의 작업 흐름은 다음과 같다.



1. __데이터 정의 (기획자):__ Excel에서 Fireball 스킬의 데미지 계수를 2.5에서 3.0으로 수정하고 저장.
2. __데이터 빌드 (자동화):__ CI/CD 파이프라인 또는 로컬 스크립트가 Excel을 skills.json 또는 skills.bin으로 변환하여 서버 폴더에 업로드.
3. __로직 작성 (개발자/기획자):__ 필요 시 Combat.lua를 수정하여 데미지 공식을 변경하거나 새로운 조건을 추가.
4. __핫 리로드 (인게임):__ 운영자가 /lua reload 명령어를 입력.
5. __적용 완료:__ 자바 엔진이 변경된 데이터와 Lua 스크립트를 즉시 메모리에 재적재하여, 서버 재시작 없이 변경 사항이 반영됨.

__5. 결론 및 기대 효과__

이 아키텍처는 마인크래프트 서버 개발의 고질적인 문제인 **"잦은 재시작과 컴파일 시간"**을 제거한다.



* __생산성 향상:__ 기획자가 데이터(Excel)만 수정해도 게임 밸런스가 바뀐다.
* __복잡한 로직 구현:__ MythicMobs의 제한된 스크립팅 기능을 튜링 완전한(Turing-complete) Lua 언어로 대체하여 디아블로 IV의 정교한 메커니즘 구현 가능.
* __성능 유지:__ 루아는 가볍고 빠르며, 무거운 연산은 여전히 자바 엔진이 담당하므로 20 TPS 유지에 유리하다.

 

이 보고서 내용은 기존의 기술 문서 사이에 삽입되거나, "구현 전략" 챕터의 하위 섹션으로 포함되어 프로젝트의 기술적 완성도를 높이는 데 사용될 수 있습니다.