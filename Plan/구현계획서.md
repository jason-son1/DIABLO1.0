__프로젝트 생크추어리(Project Sanctuary) 초기 플러그인 개발 계획__

__작성일:__ 2026-01-04 __기반 문서:__ 설계 보고서, 프로젝트 계획(구현, 전투, 아이템, 몬스터, 직업 등) __목표:__ 디아블로 IV 아키텍처 기반의 데이터 주도형 마인크래프트 RPG 엔진 구축

__0. 아키텍처 개요 (The Core Philosophy)__

본 프로젝트는 모든 콘텐츠(스킬, 아이템, 몬스터, UI)가 자바 코드가 아닌 **외부 데이터(JSON/Excel/Notebook)**에 의해 정의되는 구조를 따릅니다. 따라서 우리가 만들 플러그인은 "콘텐츠" 자체가 아니라, **"데이터를 해석하고 실행하는 엔진"**이어야 합니다.

우선적으로 개발해야 할 4대 핵심 플러그인은 다음과 같습니다.



1. __SanctuaryCore__: 데이터 로드, Lua 스크립트 엔진, ECS 관리 (두뇌)
2. __SanctuaryCombat__: 데미지 버킷 연산, 스탯 관리, 상태 이상 처리 (심장)
3. __SanctuaryItems__: 아이템 생성(RNG), NBT/PDC 직렬화, 인벤토리 로직 (뼈대)
4. __SanctuaryBridge__: Fabric 클라이언트와의 통신, Protobuf 패킷 핸들링 (신경망)

__1. SanctuaryCore (시스템의 두뇌)__

__핵심 역할:__ 외부 데이터(Excel/JSON)를 로드하고, 엔티티에 컴포넌트를 부착하며, Lua 스크립트를 통해 동적 로직을 수행하는 중앙 제어 장치입니다.

__1.1 주요 기능__



* __ETL 파이프라인:__ 서버 시작 시 /data/ 폴더 내의 JSON/Protobuf 파일을 읽어 메모리에 캐싱.
* __ECS (Entity Component System) 매니저:__ 마인크래프트 엔티티(UUID)에 가상의 데이터 컴포넌트(스탯, 직업, 파라곤 정보)를 매핑.
* __Lua 샌드박스:__ 기획자가 작성한 .lua 스크립트를 자바 내부에서 실행하여 게임 로직(스킬 효과, 트리거) 처리.
* __Hot-Reload:__ 서버 재시작 없이 데이터와 스크립트만 갱신하는 기능 (/sanctuary reload).

__1.2 내부 패키지 및 클래스 구상__

package com.sanctuary.core;

 

// 1. 데이터 관리 (ETL)

class DataManager {

    void loadAll(); // JSON -> Java Object 파싱 (Gson/Jackson)

    &lt;T> T getData(String id, Class&lt;T> type); // 데이터 조회 제네릭 메서드

}

 

// 2. 엔티티 컴포넌트 시스템 (ECS)

class EntityManager {

    // UUID를 키로 하여 컴포넌트 컨테이너를 관리

    Map&lt;UUID, ComponentContainer> entityMap;

	

    void attachComponent(Entity e, Component c);

    &lt;T extends Component> T getComponent(Entity e, Class&lt;T> type);

}

 

// 3. Lua 스크립트 엔진 (LuaJ 또는 LuaInMinecraftBukkit 연동)

class ScriptEngine {

    void executeScript(String scriptName, Event event); // 이벤트 발생 시 루아 함수 호출

    void registerAPI(String name, Object function); // 루아에서 자바 기능 호출 허용

}

__2. SanctuaryCombat (전투 및 스탯 엔진)__

__핵심 역할:__ 바닐라 마인크래프트의 데미지 계산을 __전면 무효화__하고, 보고서에 명시된 __'데미지 버킷'__ 공식과 __'상태 이상'__ 로직을 적용합니다.

__2.1 주요 기능__



* __속성 컨테이너 (AttributeContainer):__ 플레이어 및 몬스터의 모든 스탯(힘, 민첩, 화염 피해 등)을 Map&lt;String, Double> 형태로 관리.
* __커스텀 데미지 파이프라인:__ EntityDamageEvent를 가로채어 [무기 데미지 -> 합연산 -> 곱연산 -> 치명타/취약] 공식 적용.
* __상태 이상 매니저:__ 바닐라 포션 효과가 아닌 커스텀 태그(취약, 보강, 제압, 출혈 등) 관리 및 시각 효과(Display Entity) 처리.
* __직업 메커니즘 훅:__ 혼령사(활력), 야만용사(아스날) 등의 고유 자원 로직 처리.

__2.2 내부 패키지 및 클래스 구상__

package com.sanctuary.combat;

 

// 1. 스탯 관리

class StatManager {

    // 장비, 패시브, 버프 등 모든 소스의 스탯을 합산하여 최종 값 캐싱

    void recalculateStats(Player p);

}

 

// 2. 데미지 계산 (핵심)

class DamagePipeline {

    @EventHandler

    void onDamage(EntityDamageByEntityEvent e) {

        e.setDamage(0); // 바닐라 데미지 무효화

       

        DamageContext ctx = new DamageContext(attacker, victim);

       

        // 파이프라인 실행

        double base = calculateWeaponDamage(ctx);

        double additive = calculateAdditiveBucket(ctx); // 합연산

        double multi = calculateMultipliers(ctx);   	// 곱연산

        double crit = calculateCrit(ctx);           	// 치명타

       

        double finalDamage = base * additive * multi * crit;

        applyFinalDamage(ctx, finalDamage);

	}

}

 

// 3. 상태 이상

class StatusEffectManager {

    void applyEffect(Entity target, String effectId, int duration, int stacks);

    // 예: "VULNERABLE" 태그가 있으면 데미지 계산 시 1.2배 적용

}

__3. SanctuaryItems (아이템 및 크래프팅)__

__핵심 역할:__ 'Loot Reborn' 시스템(담금질, 명품화)을 구현하고, 복잡한 아이템 데이터를 __NBT/PDC__에 최적화하여 저장/관리합니다.

__3.1 주요 기능__



* __아이템 생성기 (Generator):__ 데이터에 정의된 접두사/접미사, 가중치(Weight)에 따라 절차적으로 아이템 생성 (RNG).
* __PDC 직렬화:__ 아이템의 모든 스탯을 PersistentDataContainer에 JSON 또는 Protobuf 바이너리 형태로 압축 저장.
* __크래프팅 시스템:__ 담금질(확률적 옵션 부여, 벽돌 시스템), 명품화(4/8/12단계 크리티컬 강화) 로직 구현.
* __그리드 인벤토리 백엔드:__ 클라이언트 UI와 통신하기 위한 가상의 인벤토리(좌표 x, y, w, h) 데이터 모델 관리.

__3.2 내부 패키지 및 클래스 구상__

package com.sanctuary.items;

 

// 1. 아이템 데이터 구조 (NBT 매핑용)

class RpgItemData {

    String templateId; // 베이스 아이템 ID

    int itemPower; 	// 위력

    Map&lt;String, Double> affixes; // 속성 목록

    TemperingData tempering; 	// 담금질 상태

    MasterworkingData masterworking; // 명품화 상태

	

    // 이 객체를 JSON으로 변환하여 ItemStack의 PDC에 저장

}

 

// 2. 생성 및 파밍

class ItemFactory {

    ItemStack generateLoot(Player player, MobType mob); // 스마트 룻 로직 적용

}

 

// 3. 제작 시스템

class CraftingManager {

    // 담금질 시도

    boolean attemptTemper(ItemStack item, TemperManual manual) {

        // 확률 계산 및 내구도 차감 로직

        // 실패 시 'Bricked' 상태 저장

	}

}

__4. SanctuaryBridge (네트워킹 및 UI)__

__핵심 역할:__ Spigot 서버와 Fabric 클라이언트(모드) 간의 고속 통신을 담당합니다. 마인크래프트의 기본 채널을 넘어선 데이터를 전송합니다.

__4.1 주요 기능__



* __Protobuf 패킷 처리:__ 구글 Protobuf로 정의된 .proto 파일을 기반으로 데이터를 직렬화/역직렬화하여 대역폭 절약.
* __Netty 채널 훅:__ protocol:handshake, rpg:inventory_sync, rpg:hud_update 등의 커스텀 채널 관리.
* __서버 주도형 UI (SDUI):__ 서버에서 JSON으로 UI 레이아웃을 보내면 클라이언트가 이를 그리는 프로토콜 구현.

__4.2 내부 패키지 및 클래스 구상__

package com.sanctuary.network;

 

// 1. 패킷 관리

class PacketManager {

    void sendPacket(Player p, GeneratedMessageV3 packet); // Protobuf 메시지 전송

    void registerHandler(String channel, PacketListener listener);

}

 

// 2. 인벤토리 동기화

class InventorySyncService {

    // SanctuaryItems의 가상 인벤토리 데이터를 Protobuf 패킷으로 변환하여 전송

    void syncInventory(Player p, VirtualInventory inv);

}

 

// 3. UI 제어

class UIManager {

    void openWindow(Player p, String layoutJson); // 클라이언트에게 특정 UI 오픈 명령

}

__5. 구현 우선순위 및 통합 워크플로우__

가장 먼저 만들어야 할 순서는 다음과 같습니다.



1. __Phase 1: SanctuaryCore 구축__
    * Excel/JSON 데이터를 자바 객체로 불러오는 기능부터 만드세요. 이게 없으면 다른 플러그인은 껍데기입니다.
2. __Phase 2: SanctuaryItems 기반 마련__
    * NBT에 데이터를 저장하고 읽어오는 기능을 만드세요. (전투 테스트를 하려 해도 '공격력'이 적힌 아이템이 있어야 합니다.)
3. __Phase 3: SanctuaryCombat 기본 로직__
    * EntityDamageEvent를 캔슬하고, 위에서 만든 아이템의 NBT 데이터를 읽어 데미지를 로그에 띄우는 것부터 시작하세요.
4. __Phase 4: SanctuaryBridge 연결__
    * 서버의 데이터를 클라이언트 모드로 전송하여 화면에 띄우는 작업을 진행하세요.

이 계획은 보고서에 있는 방대한 내용을 __실제로 코딩 가능한 단위__로 쪼갠 것입니다. 이 4개의 플러그인이 완성되면, 그 위에 MythicMobs나 WorldGuard 같은 기존 플러그인을 '보조 도구'로 붙여서 시스템을 확장하면 됩니다.

 

구체화

 \
 SanctuaryCore는 프로젝트 생크추어리의 **'두뇌(Brain)'**이자 **'중추 신경계(Central Nervous System)'**입니다. 이 플러그인은 게임 콘텐츠(아이템, 스킬, 몹)를 직접 구현하는 것이 아니라, 외부 데이터(JSON/Protobuf)를 읽어들이고, 이를 인게임 객체(Entity)에 연결하며, Lua 스크립트를 통해 로직을 실행하는 __엔진(Engine)__ 역할을 수행해야 합니다.

제공해주신 문서(, , )를 바탕으로 __Phase 1__ 단계에서 구현해야 할 SanctuaryCore의 기능 명세를 구체화했습니다.


---

__SanctuaryCore 기술 명세서 (Technical Specification)__

__버전:__ 0.1.0 (Phase 1 Alpha) __핵심 역할:__ ETL(데이터 로드), ECS(엔티티 컴포넌트), Lua Bridge(스크립트 연결), Event Bus(이벤트 전파)

__1. 데이터 파이프라인 (ETL & Data Management)__

가장 먼저 구현해야 할 부분은 "노트북(Notebook) 데이터를 서버 메모리로 올리는 과정"입니다.

__1.1 DataManager (데이터 매니저)__

외부 파일 시스템에서 데이터를 읽어와 Java POJO(Plain Old Java Object)로 매핑하고 캐싱합니다.



* __지원 포맷:__ JSON (개발 단계용), Protobuf/FlatBuffers (배포 및 고성능용)
* __로드 프로세스:__
    1. 서버 시작 시 /plugins/SanctuaryCore/data/ 디렉토리 스캔.
    2. domain 별로 파일 분류 (예: stats, skills, monsters).
    3. Gson/Jackson (JSON) 또는 Protobuf Parser를 이용해 객체화.
    4. Registry 맵에 ID를 Key로 하여 저장.
* __Java 인터페이스:__

Java

public interface DataManager {

	void loadAll(); // 전체 리로드 (Hot-Reload 지원)

	&lt;T> T getData(String domain, String id, Class&lt;T> type);

	boolean validateData(String domain, String id); // 데이터 무결성 검사

}

__1.2 Registry (레지스트리 시스템)__

데이터 타입별로 저장소를 분리하여 관리합니다.



* StatRegistry: 힘, 민첩, 지능 등 스탯 정의 파일 로드.
* TagRegistry: '정예', '보스', '취약' 등 시스템 태그 정의.
* StringPool: 다국어 지원 및 메모리 최적화를 위한 문자열 풀.


---

__2. 엔티티 컴포넌트 시스템 (ECS Architecture)__

마인크래프트 엔티티(Entity)에 디아블로식 데이터(스탯, 상태, 태그)를 붙이기 위한 가상 레이어입니다.

__2.1 SanctuaryEntity (래퍼 클래스)__

모든 로직은 Bukkit의 Entity가 아닌, 이를 감싼 SanctuaryEntity를 통해 처리됩니다.



* __구조:__

Java

public class SanctuaryEntity {

	private final UUID uuid;

	private final Entity bukkitEntity;

	private final ComponentContainer components; // 컴포넌트 저장소

 

	public &lt;T extends Component> T getComponent(Class&lt;T> componentClass);

	public void attachComponent(Component component);

}

__2.2 핵심 컴포넌트 (Phase 1 필수 구현)__



* __IdentityComponent:__ 엔티티의 고유 ID (예: fallen_shaman_01), 레벨, 소속 패밀리(Family) 정보.
* __AttributeComponent (속성 컨테이너):__
    * Map&lt;String, Double> 구조로 모든 스탯 관리.
    * Base(기본값), Additive(합연산), Multiplicative(곱연산) 값을 분리하여 저장해야 함 (데미지 버킷 구현을 위함).
    * 기능: getAttributeValue(String key), addModifier(String key, double value, Type type).
* __TagComponent:__
    * Set&lt;String> 구조.
    * 예: ELITE, BOSS, UNDEAD, VULNERABLE(취약 상태).
* __StateComponent (상태 관리):__
    * 그로기(Stagger) 게이지, 현재 동작 상태(Casting, Stunned) 관리.

__2.3 EntityManager (생명주기 관리)__



* EntitySpawnEvent: 몬스터 스폰 시 자동으로 SanctuaryEntity 생성 및 데이터 주입.
* PlayerJoinEvent: 플레이어 접속 시 PersistentDataContainer (PDC)에서 데이터 로드.
* EntityRemove/Quit: 메모리 해제 및 데이터 저장(PDC/DB).


---

__3. Lua 스크립트 엔진 (The Bridge)__

"자바는 실행하고, 루아는 연결한다"는 원칙을 구현합니다.

__3.1 ScriptEngine (엔진 코어)__



* __라이브러리:__ LuaInMinecraftBukkit II 또는 LuaJ 라이브러리 음영(Shading) 처리.
* __역할:__ .lua 파일을 로드하고 컴파일하여 메모리에 상주.
* __샌드박싱:__ 루아 스크립트가 서버의 위험한 기능(파일 삭제, 시스템 종료 등)에 접근하지 못하도록 제한된 Globals 환경 제공.

__3.2 Java-Lua 바인딩 (API 노출)__

Lua 스크립트에서 자바의 기능을 호출할 수 있도록 메서드를 매핑합니다.



* __Lua에서 사용 예시:__

Lua

-- Java의 SanctuaryEntity 객체가 'caster'로 넘어옴

local strength = caster:getStat("STRENGTH")

if strength > 50 then

    caster:playSound("ENTITY_GENERIC_EXPLODE")

end



* __Java 구현:__

Java

public class LuaBridge {

	public double getStat(SanctuaryEntity entity, String statKey) {

    	return entity.getComponent(AttributeComponent.class).getValue(statKey);

	}

	public void playSound(SanctuaryEntity entity, String sound) {

    	// Bukkit Sound API 호출

	}

}


---

__4. 이벤트 버스 및 트리거 시스템 (Event & Trigger)__

마인크래프트의 이벤트를 캡처하여 Sanctuary 시스템 내부로 전파하는 **라우터(Router)**입니다.

__4.1 SanctuaryEventBus__



* Bukkit의 EventHandler와 유사하지만, SanctuaryEntity를 기반으로 작동합니다.
* __주요 이벤트:__
    * SanctuaryDamageEvent: 데미지 계산 전 단계. (Combat 플러그인에서 처리 예정)
    * SanctuarySkillCastEvent: 스킬 시전 시도.
    * SanctuaryItemInteractEvent: 아이템 사용.

__4.2 트리거 리스너 (Trigger Listener)__



* 특정 조건이 만족될 때 Lua 함수를 실행하는 로직입니다.
* 구현 예: onAttack, onHit, onKill, onEquip.
* Java는 이벤트를 감지하면 해당 엔티티에 연결된 Lua 스크립트의 함수(예: function onHit(attacker, victim))를 호출합니다.


---

__5. 데이터 저장소 및 직렬화 (Persistence)__

데이터를 영구적으로 저장하는 계층입니다.

__5.1 NBT/PDC 어댑터__



* 플레이어와 아이템의 데이터는 마인크래프트의 PersistentDataContainer (PDC)에 저장합니다.
* __직렬화 방식:__ 복잡한 객체(예: 스킬 트리 상태)는 JSON 문자열 또는 Protobuf 바이트 배열로 변환하여 PDC의 단일 키(sanctuary_data)에 저장합니다.
* __이유:__ NBT 태그가 너무 많아지면 네트워크 패킷이 무거워지므로 압축 저장이 필수입니다.

__5.2 글로벌 설정 (Config)__



* config.yml: DB 연결 정보, 디버그 모드, 기본 언어 설정.
* messages.yml: 시스템 메시지 (다국어 지원).


---

__Phase 1 개발 체크리스트 (우선순위 순)__



1. [ ] __프로젝트 세팅:__ Gradle 멀티 모듈 설정 (core, combat, items 등). Protobuf 컴파일러 연동.
2. [ ] __DataManager 구현:__ 간단한 JSON 파일(예: stats.json)을 읽어서 Java Map에 로드하는 기능.
3. [ ] __ECS 뼈대 구축:__ SanctuaryEntity 클래스 생성 및 AttributeComponent 부착 테스트.
4. [ ] __PDC 연동:__ 플레이어 접속 시 데이터를 PDC에서 로드하고, 변경 후 로그아웃 시 저장되는지 확인.
5. [ ] __Lua 엔진 연동:__ 간단한 test.lua 파일을 로드하고, 자바에서 helloworld() 함수를 호출하여 콘솔에 출력하기.
6. [ ] __Hot-Reload:__ /sanctuary reload 명령어 입력 시 JSON 데이터와 Lua 스크립트가 갱신되는지 확인.

이 SanctuaryCore가 완성되면, 이후 개발할 Combat(전투), Items(아이템) 플러그인은 이 Core가 제공하는 API(getStat, getData)를 사용하여 __데이터에만 집중__할 수 있게 됩니다.

 

 

 

 

SanctuaryCombat은 **'심장(Heart)'**에 해당합니다. SanctuaryCore가 공급하는 정적 데이터(혈액)를 받아, 실시간 전투 연산(박동)으로 변환하여 순환시키는 엔진입니다.

이 모듈의 핵심 목표는 __마인크래프트의 기본 데미지 공식을 완전히 무효화__하고, 디아블로 IV(Season 6)의 __'데미지 버킷(Damage Bucket)'__ 이론을 서버 틱(Tick) 단위로 정밀하게 구현하는 것입니다.


---

__SanctuaryCombat 기술 명세서 (Technical Specification)__

__버전:__ 0.1.0 (Phase 2 Alpha) __핵심 역할:__ 스탯 관리, 데미지 파이프라인, 상태 이상(Status Effect), 직업 고유 메커니즘 처리

__1. 스탯 엔진 (Stat Engine & AttributeContainer)__

플레이어와 몬스터의 능력치를 관리하는 컨테이너입니다. 단순한 Map 구조를 넘어, 디아블로식 합연산/곱연산 로직을 지원해야 합니다.

__1.1 AttributeContainer (속성 컨테이너)__

모든 SanctuaryEntity는 하나의 AttributeContainer를 가집니다. 스탯은 실시간으로 계산되지 않고, 장비 교체나 버프 적용 시 __'재계산(Recalculate)'__ 되어 캐싱됩니다.



* __데이터 구조:__

Java

public class StatValue {

	private double base;      	// 기본값 (아이템 깡스탯 + 기본 스탯)

	private double additive;  	// 합연산 퍼센트 (예: +20%)

	private double multiplicative; // 곱연산 퍼센트 (예: x1.15)

 

	public double getFinalValue() {

    	return base * (1.0 + additive) * multiplicative;

	}

}



* __주요 스탯 키 (Key Definitions):__
    * __Core:__ STRENGTH, INTELLIGENCE, WILLPOWER, DEXTERITY
    * __Offensive:__ WEAPON_DAMAGE, CRIT_CHANCE, ATTACK_SPEED, OVERPOWER_DAMAGE
    * __Defensive:__ ARMOR, RESISTANCE_FIRE, MAX_HP, BARRIER_MAX
    * __Utility:__ RESOURCE_MAX, RESOURCE_REGEN, COOLDOWN_REDUCTION

__1.2 스탯 재계산 로직 (The Recalculation Loop)__

장비 장착(InventoryChangeEvent)이나 패시브 습득 시 트리거됩니다.



1. __Reset:__ 모든 스탯을 0으로 초기화.
2. __Base Injection:__ SanctuaryCore에서 로드한 기본 스탯 주입.
3. __Item Iterate:__ 장착 중인 모든 아이템의 NBT/PDC 스탯 합산.
4. __Paragon/Skill:__ 활성화된 파라곤 노드와 패시브 스킬 보너스 합산.
5. __Main Stat Scaling:__ 주 스탯(예: 민첩)에 따른 파생 스탯(공격력, 회피율) 자동 연산.


---

__2. 데미지 파이프라인 (The Damage Pipeline)__

마인크래프트의 EntityDamageByEntityEvent를 가로채어 실행되는 핵심 연산 프로세스입니다.

__2.1 DamageContext (데미지 컨텍스트)__

이벤트 발생 시 생성되는 스냅샷 객체입니다.



* __포함 정보:__ 공격자(Entity), 피해자(Entity), 스킬 계수(Skill Coefficient), 데미지 속성(Fire/Physical 등), 태그(IsBasicAttack, IsCoreSkill).

2.2 파이프라인 단계별 연산 (Season 6 공식 적용)



1. __초기화 (Init):__ 바닐라 데미지 event.setDamage(0) 처리.
2. __무기 데미지 산출:__
    * WeaponDamage = random(MinDamage, MaxDamage) * SkillCoefficient.
3. __주 스탯 연산:__
    * MainStatBonus = MainStat * 0.1%. (별도 곱연산)
4. __합연산 버킷 (Additive Bucket) 집계:__
    * 조건부 데미지 합산: DamageVsClose, DamageVsBleeding, DamageVsElites 등.
    * __중요:__ 시즌 6 변경점에 따라 CritDamage와 VulnDamage의 추가분도 이 버킷에 합산합니다.
5. __곱연산 버킷 (Global Multipliers) 집계:__
    * 전설 위상, 패시브 등에서 [x]%로 표기된 수치들을 모두 곱합니다.
6. __치명타 및 취약 (Crit & Vuln) 적용:__
    * CritMultiplier = 치명타 발생 시 고정 1.5.
    * VulnMultiplier = 대상이 취약(Vulnerable) 상태일 때 고정 1.2.
7. __제압 (Overpower) 연산:__
    * 3% 확률(고정)로 발동. 발동 시 (CurrentHP + Fortify) * Multiplier 추가.
8. __방어 로직 (Defense):__
    * 방어도(Armor)에 따른 물리 피해 감소 (최대 85% 캡).
    * 저항(Resistance)에 따른 원소 피해 감소 (최대 70%~85%).

__2.3 결과 적용__



* 최종 데미지를 victim.setHealth() 또는 damage(finalValue)로 적용.
* __데미지 인디케이터(DDI):__ 계산 결과에 따라 색상이 다른 홀로그램 출력 (치명타=노랑, 제압=하늘색, 취약=보라).


---

__3. 상태 이상 매니저 (Status Effect Manager)__

바닐라 포션 효과가 아닌, 시스템 내부적으로 관리되는 태그 및 타이머 시스템입니다.

__3.1 StatusEffect 클래스__



* __필드:__ Type (BUFF/DEBUFF), ID ("VULNERABLE"), Duration (틱), Stacks, Value.
* __작동 방식:__ SanctuaryEntity의 update() 루프에서 매 틱마다 지속시간 차감.

3.2 주요 상태 구현



* __취약 (Vulnerable):__
    * 효과: 받는 피해 x1.2 (파이프라인 단계 6에서 적용).
    * 시각화: 엔티티 테두리 발광(Glowing) + 보라색 파티클.
* __보강 (Fortify):__
    * 효과: 별도의 자원 풀(FortifyAmount)로 관리. Fortify >= CurrentHP일 때 받는 피해 15% 감소.
* __보호막 (Barrier):__
    * 효과: 체력보다 먼저 소모되는 임시 HP.
    * 구현: 데미지 파이프라인의 마지막 단계에서 BarrierAmount를 먼저 차감하고 남은 데미지만 HP에 적용.
* __그로기 (Stagger - 보스 전용):__
    * 효과: CC기 적중 시 게이지 상승 -> 100% 도달 시 10초간 무력화 및 받는 피해 증가.


---

__4. 직업 리소스 및 메커니즘 훅 (Class Mechanics Hooks)__

직업별 특수 자원과 메커니즘을 처리하는 로직입니다.

__4.1 커스텀 자원 시스템 (Resource System)__

마인크래프트의 경험치 바(Exp Bar)를 사용하여 커스텀 자원을 표시합니다.



* __자원 유형:__ 마나(Mana), 분노(Fury), 기력(Energy), 활력(Vigor), 정수(Essence).
* __재생 로직:__
    * Mana: 초당 일정량 자동 회복.
    * Fury/Vigor: 자동 회복 없음. 기본 기술(Basic Skill) 적중 시 회복 (onHit 트리거 연동).

__4.2 직업별 핸들러 (Class Handlers)__



* __야만용사 (Barbarian) - 아스날(Arsenal):__
    * 스킬 시전 시, 해당 스킬 태그(예: DualWield)에 맞춰 가상 인벤토리 슬롯의 무기 스탯을 데미지 컨텍스트에 주입.
* __혼령사 (Spiritborn) - 혼령 전당:__
    * 주 혼령(Primary Spirit) 선택 시, 모든 스킬에 해당 혼령 태그(예: JAGUAR) 부여.
    * DamageContext 생성 시 이 태그를 확인하여 패시브 보너스(예: 재규어 태그 시 화염 피해 추가) 적용.
* __도적 (Rogue) - 연계 점수 (Combo Points):__
    * 기본 기술 적중 시 ComboPoints 변수 증가.
    * 핵심 기술 사용 시 ComboPoints를 소모하고 데미지 배율 증가.


---

__Phase 2 개발 체크리스트 (우선순위 순)__



1. [ ] __StatManager 구현:__ AttributeContainer 클래스 작성 및 기본/합연산/곱연산 분리 로직 구현.
2. [ ] __DamagePipeline 구축:__ EntityDamageByEntityEvent 리스너 작성. 바닐라 데미지 0으로 설정 후 로그에 "Custom Damage Calculated: [Value]" 출력 테스트.
3. [ ] __시즌 6 공식 적용:__ 무기데미지 -> 주스탯 -> 합연산 -> 곱연산 순서로 계산되는 수식 코드 작성.
4. [ ] __상태 이상 프레임워크:__ StatusEffectManager 작성. '취약' 상태 부여 시 데미지 20% 증가 확인.
5. [ ] __보호막(Barrier) 로직:__ 플레이어에게 보호막 부여 후, 피격 시 체력 대신 보호막 수치가 깎이는지 테스트.
6. [ ] __직업 자원 UI:__ 경험치 바를 사용하여 '분노'나 '활력'이 차오르고 줄어드는 시각적 구현.
7. [ ] __더미(Dummy) 테스트:__ 허수아비 엔티티를 소환하여 장비 교체 시 데미지 수치가 변하는지 검증.

SanctuaryCombat은 서버의 밸런스를 결정짓는 가장 민감한 부분이므로, **단위 테스트(Unit Test)**를 통해 공식의 정확성을 지속적으로 검증해야 합니다.

 \
 \
 \
 SanctuaryItems는 서버의 **'뼈대(Skeleton)'**입니다. SanctuaryCore가 로드한 데이터를 바탕으로 실제 인게임 객체(ItemStack)를 생성하고, SanctuaryCombat이 연산할 수 있는 데이터 구조(NBT/PDC)를 제공하며, 디아블로 4의 핵심 루프인 __파밍-담금질-명품화__ 시스템을 구동합니다.

이 모듈의 핵심 목표는 __"Loot Reborn(전리품의 재탄생)"__ 아키텍처를 구현하여, 바닐라 마인크래프트의 단순한 인챈트 시스템을 완전히 대체하는 것입니다.


---

__SanctuaryItems 기술 명세서 (Technical Specification)__

__버전:__ 0.1.0 (Phase 3 Alpha) __핵심 역할:__ 아이템 생성(RNG), PDC 직렬화, 담금질/명품화 로직, 스마트 룻, 가상 인벤토리 백엔드

__1. 데이터 구조 및 직렬화 (Data Structure & Serialization)__

아이템의 모든 정보는 Lore가 아닌 PersistentDataContainer (PDC)에 바이너리/JSON 형태로 저장되어야 합니다. 이는 성능 최적화와 데이터 무결성을 위함입니다.

__1.1 RpgItemData (POJO)__

아이템의 상태를 메모리 상에서 관리하는 객체입니다.

Java

public class RpgItemData {

	private String uuid;          	// 아이템 고유 ID (복제 방지용)

	private String templateId;    	// 베이스 아이템 ID (예: sword_ancestral)

	private int itemPower;        	// 아이템 위력 (속성 범위 결정) [cite: 591]

	private ItemRarity rarity;    	// 희귀도 (RARE, LEGENDARY, UNIQUE, MYTHIC)

	

	// 속성 (Affixes)

	private List&lt;AffixInstance> implicitAffixes; // 기본 지속 효과 (무기 고유) [cite: 667]

	private List&lt;AffixInstance> explicitAffixes; // 랜덤 접사 (어픽스)

	

	// 제작 상태

	private TemperingData tempering;  	// 담금질 상태 (내구도, 부여된 옵션)

	private MasterworkingData masterworking; // 명품화 상태 (현재 랭크, 크리티컬 적중 인덱스)

	

	// 전설 위상 (Aspect) - 소켓 방식 또는 별도 필드

	private String aspectId;

	private double aspectValue;

}

__1.2 ItemSerializer (PDC 어댑터)__

ItemStack과 RpgItemData 간의 변환을 담당합니다.



* __Write:__ RpgItemData 객체를 Protobuf 바이트 배열로 변환 -> PDC에 NamespacedKey("sanctuary", "data")로 저장.
* __Read:__ 아이템 상호작용/장착 시 PDC에서 바이트 배열을 읽어 RpgItemData로 역직렬화.
* __Sync:__ 데이터 변경(예: 강화 성공) 시 즉시 PDC를 업데이트하고, ItemMeta의 Lore를 재생성하여 플레이어에게 시각적 정보를 갱신.


---

__2. 전리품 생성 엔진 (Loot Generation Engine)__

몬스터 사망 시 어떤 아이템을 떨어뜨릴지 결정하는 공장(Factory)입니다.

__2.1 LootFactory (생성기)__



* __스마트 룻 (Smart Loot):__
    * 플레이어 직업 감지. (예: 강령술사)
    * 85% 확률로 해당 직업 착용 가능 무기/방어구 및 주 스탯(지능) 아이템 생성.
    * 15% 확률로 타 직업 아이템 생성 (부캐릭터 육성 유도).
* __아이템 위력 산출:__ 몬스터 레벨에 비례하여 ItemPower 범위 결정. (예: Lv 100 몬스터 -> 위력 925 확정 드롭).

__2.2 AffixRoller (속성 추첨기)__



* __상급 속성 (Greater Affix - GA):__
    * 선조(Ancestral) 등급 아이템 생성 시, 각 어픽스마다 Random(0, 1) 실행.
    * 당첨 시(약 5~10%), 해당 어픽스 수치를 MaxRoll * 1.5로 고정하고 isGA = true 마킹.
* __속성 풀 필터링:__
    * 아이템 부위(Slot)와 타입(Type)에 따라 붙을 수 있는 어픽스 목록(Pool)을 로드.
    * 조건부 태그 배제: '담금질' 전용 옵션은 드롭 생성 단계에서 배제해야 함.


---

__3. 크래프팅 시스템: 대장간 (The Smithy)__

아이템의 잠재력을 해방하는 제작 시스템입니다. UI는 클라이언트가 담당하더라도, 로직 검증은 서버의 SanctuaryItems가 수행합니다.

__3.1 담금질 매니저 (TemperingManager)__

전설 아이템에 새로운 속성 2개를 부여하는 과정입니다.



* __데이터 모델:__ TemperingData { int durability (기본 5); List&lt;Affix> appliedAffixes; }
* __매뉴얼 시스템:__ TemperingManual 아이템 사용 시 카테고리(무기, 공격, 방어 등) 확인.
* __로직 (attemptTemper):__
    1. 내구도 확인: durability > 0 ? 통과 : 차단(Bricked 상태).
    2. RNG 롤: 매뉴얼 내 옵션 중 하나를 가중치 랜덤 선택.
    3. 적용: RpgItemData에 어픽스 추가/교체.
    4. 비용 차감: 내구도 -1.
    5. 결과 반환: 성공 여부 및 변경된 데이터 리턴 (클라이언트 UI 연출용).

__3.2 명품화 매니저 (MasterworkingManager)__

아이템 성능을 12단계까지 강화합니다.



* __데이터 모델:__ MasterworkingData { int rank (0~12); List&lt;Integer> critIndices; }
* __강화 로직 (upgrade):__
    * __일반 단계 (1~3, 5~7, 9~11):__ 모든 ExplicitAffix와 TemperingAffix의 수치를 CurrentValue * 1.05 (5% 증가).
    * __크리티컬 단계 (4, 8, 12):__ 랜덤한 1개의 어픽스를 선택하여 CurrentValue * 1.25 (25% 대폭 증가).
        * 어느 옵션이 크리티컬을 맞았는지 critIndices에 기록하여, Lore 생성 시 색상(파랑/노랑/주황)으로 표시.
* __초기화 (Reset):__ 버튼 클릭 시 랭크를 0으로 되돌리고 재료는 반환하지 않음.


---

__4. 인벤토리 백엔드 (Virtual Inventory Backend)__

디아블로식 그리드 인벤토리(Tetris-style)를 구현하기 위한 서버 측 데이터 모델입니다. 클라이언트 UI가 화려하게 보여주더라도, 서버는 실제 데이터 위치를 검증해야 합니다.

__4.1 VirtualInventory__



* __구조:__ 2차원 배열 또는 리스트 List&lt;GridItem>.
    * GridItem: RpgItemData + int x, int y (위치) + int w, int h (크기).
* __검증 알고리즘 (Rectangular Packer):__
    * 아이템 이동 요청 시, 대상 좌표 (x, y)로부터 (x+w, y+h) 영역이 비어있는지 확인.
    * 충돌 시 이동 거부 패킷 전송.
* __동기화:__ 인벤토리 상태가 변경될 때마다 Protobuf 패킷으로 클라이언트에 전체/부분 상태 전송.


---

__5. 위상(Aspect) 및 소켓 시스템__

전설 위상을 보석(Gem)처럼 취급하여 탈부착하거나 각인하는 시스템입니다.

__5.1 힘의 전서 (Codex of Power)__



* __저장소:__ 플레이어 PersistentDataContainer 또는 DB에 Map&lt;String, Double> unlockedAspects 저장.
* __각인 (Imprinting):__
    * 희귀(Rare) 아이템 + 위상 선택.
    * 아이템 희귀도를 전설(Legendary)로 승급.
    * aspectId와 aspectValue를 아이템 데이터에 주입.


---

__Phase 3 개발 체크리스트 (우선순위 순)__



1. [ ] __Serializer 구현:__ ItemStack &lt;-> RpgItemData 변환기 작성. NBT 데이터가 유지되는지 테스트.
2. [ ] __베이스 아이템 DB 구축:__ 무기/방어구 종류별 JSON 정의 (예: sword_01.json).
3. [ ] __랜덤 생성기 (Factory):__ /sanctuary item generate [level] [rarity] 명령어 구현. 어픽스가 랜덤하게 붙어서 나오는지 확인.
4. [ ] __Lore 생성기:__ RpgItemData를 읽어 마인크래프트 Lore List로 변환하는 포매터 작성. (GA는 빨간색, 수치는 회색 등 색상 코드 적용).
5. [ ] __담금질 로직:__ 매뉴얼 아이템을 정의하고, 아이템에 적용 시 옵션이 추가되고 내구도가 깎이는지 테스트.
6. [ ] __명품화 로직:__ /sanctuary item upgrade 명령어로 12강까지 테스트. 4강마다 특정 옵션이 튀는지(Crit) 검증.
7. [ ] __스마트 룻 테스트:__ 강령술사로 몹을 잡았을 때 낫과 지능 아이템이 주로 나오는지 통계 테스트.

이 SanctuaryItems 플러그인은 __SanctuaryCombat__이 계산할 재료(스탯)를 공급하고, 유저에게는 __파밍의 목적__을 제공하는 핵심 모듈이므로 데이터 무결성과 생성 알고리즘의 정교함이 최우선되어야 합니다.

 \
 \
 \
 SanctuaryBridge는 **'신경망(Nervous System)'**이자 **'감각 기관(Senses)'**입니다. SanctuaryCore(두뇌)와 SanctuaryItems/Combat(장기)에서 처리된 방대한 데이터를 __Protobuf__라는 고속도로를 통해 클라이언트(Fabric 모드)로 전달하고, 유저의 입력(UI 조작)을 서버로 중계합니다.

이 모듈의 핵심 목표는 **"서버 주도형 UI (Server-Driven UI)"**를 구현하여, 클라이언트 업데이트 없이도 서버에서 UI 레이아웃과 데이터를 동적으로 제어하는 것입니다.


---

__SanctuaryBridge 기술 명세서 (Technical Specification)__

__버전:__ 0.1.0 (Phase 4 Alpha) __핵심 역할:__ 패킷 통신(Netty), Protobuf 직렬화, SDUI 렌더링, 낙관적 업데이트(Optimistic Updates)

__1. 네트워크 프로토콜 및 패킷 파이프라인 (Network & Protocol)__

마인크래프트의 기본 패킷 시스템(Plugin Message Channel) 위에서 작동하되, 성능을 위해 __Protobuf__로 압축된 바이너리 데이터를 주고받습니다.

__1.1 프로토콜 정의 (.proto)__

서버와 클라이언트가 공유하는 데이터 계약서입니다. Gradle 빌드 시 Java 클래스로 자동 컴파일됩니다.

Protocol Buffers

syntax = "proto3";

package com.sanctuary.network.proto;

 

// 패킷의 최상위 컨테이너

message SanctuaryPacket {

	enum PacketType {

    	HANDSHAKE = 0;

    	UI_OPEN = 1;

    	INVENTORY_SYNC = 2;

    	HUD_UPDATE = 3;

    	ITEM_MOVE = 4;

	}

	PacketType type = 1;

	bytes payload = 2; // 실제 데이터 (아래 메시지들 중 하나가 직렬화됨)

	int64 timestamp = 3;

}

 

// 인벤토리 그리드 동기화 [cite: 680-687]

message InventorySyncPacket {

	int32 container_id = 1;

	int32 width = 2;

	int32 height = 3;

	repeated GridItem items = 4;

}

 

message GridItem {

	string unique_id = 1;

	string template_id = 2; // 아이콘/모델 결정용

	int32 x = 3;

	int32 y = 4;

	int32 w = 5;

	int32 h = 6;

	RpgStats stats = 7; // 툴팁 표시용 데이터

}

__1.2 PacketManager (Netty 핸들러)__



* __채널 등록:__ sanctuary:network 채널을 통해 바이너리 데이터를 송수신합니다.
* __Handshake (핸드쉐이크):__ 접속 시 클라이언트 모드 버전과 서버 플러그인 버전이 일치하는지 확인합니다. 불일치 시 접속을 차단하거나 경고 UI를 띄웁니다.
* __Packet Listener (ProtocolLib):__ 서버 측에서는 ProtocolLib을 사용하여 들어오는 패킷을 가로채고 역직렬화하여 이벤트 버스로 보냅니다.


---

__2. 서버 주도형 UI 엔진 (Server-Driven UI Engine)__

클라이언트는 "그리는 방법(Renderer)"만 알고, "무엇을 그릴지(Layout)"는 서버가 결정합니다.

__2.1 UIManager (Server Side)__



* __Layout JSON 전송:__ 특정 상황(예: 대장간 NPC 클릭)에 맞춰 UI 레이아웃을 JSON 형태로 전송합니다.
    * 예: {"type": "grid_panel", "background": "texture:anvil_bg", "slots": [...]}
* __Context 관리:__ 현재 플레이어가 열고 있는 UI ID를 추적하고, 닫기 이벤트 등을 처리합니다.

__2.2 SanctuaryClient (Fabric Mod - Client Side)__



* __라이브러리:__ oωo-lib (복잡한 중첩 UI 및 애니메이션 처리에 최적화).
* __컴포넌트 렌더러:__
    * __GridPanelComponent:__ SanctuaryItems에서 정의한 w x h 크기의 아이템을 그리드 좌표에 맞춰 렌더링합니다. 셀 점유 상태를 시각화합니다.
    * __Item3DRenderer:__ 인벤토리 내의 아이템을 단순 아이콘이 아닌, 회전하는 3D 모델로 렌더링합니다. (Fabric DrawContext 활용).
    * __SocketComponent:__ 아이템 위에 보석 소켓 구멍을 오버레이로 그립니다.


---

__3. HUD 및 시각 효과 (HUD & Visuals)__

디아블로 IV 스타일의 몰입감 있는 인터페이스를 구현합니다.

__3.1 HudOverlay (Fabric)__

바닐라 체력/배고픔 바를 숨기고 커스텀 HUD를 그립니다.



* __Health/Resource Globe:__
    * 서버에서 HUD_UPDATE 패킷으로 현재 체력/자원 퍼센트(%)를 전송.
    * 클라이언트는 텍스처의 UV 좌표를 조작하여 액체가 차오르거나 출렁이는 애니메이션(Shader 또는 Texture Sheet)을 재생합니다.
* __Skill Bar:__
    * 쿨타임 정보를 받아 아이콘 위에 어두운 오버레이(Cooldwon Clock)를 그립니다.

__3.2 월드 렌더링 (World Rendering)__



* __Drop Item Highlight:__ 전설 아이템(Legendary/Ancestral) 드롭 시, WorldRenderEvents를 믹스인(Mixin)하여 아이템 엔티티 위에 __빛기둥(Light Pillar)__ 쉐이더를 그립니다.
* __Damage Indicator:__ 서버에서 데미지 패킷을 받으면, 클라이언트 전용(Client-side only) 파티클이나 텍스트를 생성하여 데미지 숫자를 띄웁니다. (서버 엔티티 부담 감소).


---

__4. 상호작용 및 최적화 (Interaction & Optimization)__

네트워크 지연(Lag)을 숨기기 위한 고급 기술입니다.

4.1 낙관적 업데이트 (Optimistic Updates)

인벤토리에서 아이템을 옮길 때 서버 응답을 기다리지 않습니다.



1. __Client Action:__ 유저가 아이템 드래그 & 드롭 -> UI 즉시 반영.
2. __Send Packet:__ 동시에 ITEM_MOVE 패킷 전송.
3. __Server Validate:__ SanctuaryItems의 가상 인벤토리에서 검증.
4. __Rollback:__ 검증 실패 시(예: 공간 부족, 복사 버그 의심), INVENTORY_SYNC 패킷을 보내 아이템을 원래 위치로 강제 이동.

__4.2 대역폭 최적화__



* __Delta Compression:__ 전체 인벤토리를 매번 보내지 않고, **변경된 슬롯(Slot Index)**의 데이터만 부분 전송합니다.
* __String Pool:__ 자주 쓰이는 문자열(예: "Legendary", "Fire Damage")은 정수형 ID로 치환하여 전송합니다.


---

__Phase 4 개발 체크리스트 (우선순위 순)__



1. [ ] __Protobuf 환경 구축:__ .proto 파일을 작성하고, Gradle generateProto 태스크를 통해 Java 클래스가 생성되는지 확인.
2. [ ] __Netty 채널 연결:__ 서버와 클라이언트 모드 간에 "Hello World" 문자열 패킷을 주고받는 테스트.
3. [ ] __oωo-lib UI 기초:__ 클라이언트에서 U 키를 누르면 빈 윈도우 창이 뜨는지 확인.
4. [ ] __인벤토리 동기화:__ 서버에서 RpgItemData 더미 데이터를 보내면, 클라이언트 UI 그리드에 아이콘이 표시되는지 확인.
5. [ ] __아이템 이동 로직:__ 클라이언트에서 아이콘을 드래그해서 다른 칸으로 옮겼을 때, 서버 로그에 "Move Request: (x1,y1) -> (x2,y2)"가 뜨는지 확인.
6. [ ] __3D 렌더링:__ 인벤토리 슬롯 안에 MinecraftClient.getInstance().getItemRenderer()를 호출하여 회전하는 검 모델 띄우기.

SanctuaryBridge가 완성되면, 플레이어는 마인크래프트가 아닌 **"마인크래프트 엔진으로 만든 디아블로 게임"**을 하는 듯한 UX를 경험하게 됩니다. 서버의 로직(Core/Combat/Items)이 아무리 훌륭해도, Bridge가 끊기면 유저는 아무것도 느낄 수 없으므로 **안정성(Stability)**이 최우선입니다.
