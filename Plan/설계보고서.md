__차세대 마인크래프트 RPG 서버 시스템 구축을 위한 종합 아키텍처 설계 보고서__

__1. 서론 및 아키텍처 비전__

현대 마인크래프트 서버 생태계는 단순한 게임 플레이 호스팅을 넘어 복잡한 소프트웨어 엔지니어링의 영역으로 진화하고 있습니다. 특히 '디아블로(Diablo)'와 같은 Action RPG(ARPG)의 깊이 있는 메커니즘—그리드 기반의 인벤토리, 복잡한 아이템 속성(Affix), 실시간 스킬 연산, 그리고 유려한 클라이언트 UI—를 마인크래프트 환경 내에서 구현하기 위해서는 기존의 플러그인 조합 방식을 넘어선, __하이브리드(Hybrid) 시스템 아키텍처__가 필수적입니다.

본 보고서는 Spigot/Paper 기반의 서버 코어와 Fabric 기반의 클라이언트 모드를 연동하여, 엔터프라이즈급 RPG 시스템을 구축하기 위한 최종적인 기술 계획서입니다. 본 설계의 핵심 철학은 __'데이터의 권위(Authority)는 서버에, 표현(Presentation)의 자유는 클라이언트에'__ 두는 것입니다. 이를 위해 서버 로직은 유연한 Lua 스크립팅 엔진으로 추상화하고, 데이터 통신은 고성능 Protobuf로 최적화하며, 클라이언트는 Fabric 모드를 통해 바닐라 마인크래프트의 UI 한계를 극복합니다.

이 보고서는 총 5개의 기술적 기둥(Pillar)으로 구성되어 있습니다:



1. __서버 엔지니어링:__ Lua 스크립트 엔진 및 MythicMobs API 확장.
2. __데이터 아키텍처:__ Protobuf 기반의 직렬화 및 데이터 정의.
3. __네트워킹 레이어:__ ProtocolLib과 Netty를 이용한 커스텀 패킷 파이프라인.
4. __클라이언트 모드:__ Fabric 및 oωo-lib을 활용한 디아블로 스타일 UI 구현.
5. __리소스 및 모델링:__ 3D 모델 렌더링 및 에셋 관리 전략.


---

__2. 시스템 아키텍처 개요 및 기술 스택 선정__

성공적인 RPG 서버 구축을 위해서는 각 계층(Layer)에 가장 적합한 기술을 선정하고 이들 간의 유기적인 통합이 선행되어야 합니다.

__2.1 핵심 기술 스택 비교 및 선정__

 


<table>
  <tr>
   <td><strong>구성 요소</strong>
   </td>
   <td><strong>선정 기술</strong>
   </td>
   <td><strong>대안 기술</strong>
   </td>
   <td><strong>선정 사유 및 기술적 우위</strong>
   </td>
  </tr>
  <tr>
   <td><strong>서버 코어</strong>
   </td>
   <td><strong>Paper (Spigot Fork)</strong>
   </td>
   <td>Fabric Server, Sponge
   </td>
   <td>Paper는 방대한 플러그인 생태계(MythicMobs 등)와의 호환성이 뛰어나며 비동기 청크 로딩 등 성능 최적화가 검증됨.<sup>1</sup>
   </td>
  </tr>
  <tr>
   <td><strong>스크립팅</strong>
   </td>
   <td><strong>LuaInMinecraftBukkit II</strong>
   </td>
   <td>Skript, Denizen
   </td>
   <td>Skript는 구문 분석 오버헤드가 크고 복잡한 자료구조 처리에 한계가 있음. Lua는 C/C++ 레벨의 퍼포먼스와 JIT 컴파일을 지원하며, 샌드박싱이 용이함.<sup>2</sup>
   </td>
  </tr>
  <tr>
   <td><strong>데이터 직렬화</strong>
   </td>
   <td><strong>Protocol Buffers (Protobuf)</strong>
   </td>
   <td>JSON, NBT, FlatBuffers
   </td>
   <td>JSON은 파싱 비용이 높고 대역폭을 낭비함. Protobuf는 스키마 기반의 강력한 타입 안정성과 컴팩트한 바이너리 크기를 제공하여 네트워크 부하를 최소화함.<sup>4</sup>
   </td>
  </tr>
  <tr>
   <td><strong>클라이언트</strong>
   </td>
   <td><strong>Fabric Mod Loader</strong>
   </td>
   <td>Forge/NeoForge
   </td>
   <td>Fabric은 믹스인(Mixin)을 통한 가벼운 바닐라 코드 주입이 가능하여 UI 커스터마이징 개발 속도가 빠르고 성능이 우수함.<sup>6</sup>
   </td>
  </tr>
  <tr>
   <td><strong>UI 라이브러리</strong>
   </td>
   <td><strong>oωo-lib</strong>
   </td>
   <td>LibGui, Cotton
   </td>
   <td>oωo-lib은 복잡한 중첩 레이아웃과 애니메이션 처리에 특화되어 있어 디아블로 스타일의 복합적인 UI 구성에 최적임.<sup>8</sup>
   </td>
  </tr>
  <tr>
   <td><strong>엔티티 엔진</strong>
   </td>
   <td><strong>MythicMobs Premium</strong>
   </td>
   <td>Custom Entities
   </td>
   <td>MythicMobs의 API는 업계 표준이며, 커스텀 메카닉 등록을 통해 Lua 엔진과 손쉽게 연동 가능함.<sup>10</sup>
   </td>
  </tr>
</table>



---

__3. 데이터 정의 및 직렬화 전략 (Protobuf)__

RPG 시스템, 특히 디아블로 스타일의 아이템 체계에서는 하나의 아이템이 수십 개의 가변 속성(내구도, 소켓에 박힌 보석, 접두사/접미사, 제작자 서명 등)을 가집니다. 이를 마인크래프트 표준 NBT(Named Binary Tag)로 처리할 경우, 네트워크 패킷 크기가 비대해지고 서버 틱(Tick) 저하의 주원인이 됩니다. 따라서 구글의 __Protocol Buffers (Protobuf)__ 를 도입하여 데이터 구조를 최적화해야 합니다.

__3.1 Protobuf 스키마 설계 (.proto)__

Protobuf는 .proto 파일을 통해 데이터 구조(Schema)를 정의합니다. 이는 서버(Java)와 클라이언트(Fabric)가 공유하는 '계약서' 역할을 합니다.

__3.1.1 아이템 및 인벤토리 구조 정의__

디아블로 인벤토리의 핵심은 '그리드(Grid)' 시스템입니다. 아이템은 단순히 슬롯 인덱스(0~35)를 가지는 것이 아니라, (x, y) 좌표와 width, height 크기 속성을 가집니다.

 

Protocol Buffers

 

syntax = "proto3"; \
 \
 package com.rpgserver.network.proto; \
 \
 option java_package = "com.rpgserver.network.generated"; \
 option java_outer_classname = "RpgProtocol"; \
 \
 // 인벤토리 동기화 패킷 \
 message InventorySyncPacket { \
     int32 container_id = 1;      // 컨테이너 ID (플레이어 인벤토리, 창고 등) \
     int32 max_width = 2;         // 그리드 가로 크기 \
     int32 max_height = 3;        // 그리드 세로 크기 \
     repeated RpgItem items = 4;  // 포함된 아이템 목록 \
 } \
 \
 // RPG 아이템 정의 \
 message RpgItem { \
     string unique_id = 1;        // 데이터베이스 UUID \
     string prototype_id = 2;     // 아이템 원본 ID (예: "sword_inferno_ancient") \
     \
     // 그리드 위치 데이터 \
     int32 position_x = 3; \
     int32 position_y = 4; \
     int32 size_w = 5;            // 아이템 가로 크기 (2칸 차지 등) \
     int32 size_h = 6;            // 아이템 세로 크기 \
     \
     // 동적 속성 (Stats) \
     RpgStats stats = 7; \
     \
     // 소켓 시스템 (재귀적 정의 가능) \
     repeated Socket sockets = 8; \
     \
     // 시각적 오버라이드 \
     int32 custom_model_data = 9; \
     string rarity = 10;          // "LEGENDARY", "EPIC" 등 \
 } \
 \
 message RpgStats { \
     float min_damage = 1; \
     float max_damage = 2; \
     map&lt;string, float> attributes = 3; // 예: {"crit_chance": 0.15, "fire_damage": 20.0} \
     int64 durability_current = 4; \
     int64 durability_max = 5; \
 } \
 \
 message Socket { \
     int32 socket_index = 1; \
     bool is_filled = 2; \
     RpgItem socketed_gem = 3;    // 소켓 안에 박힌 아이템도 RpgItem으로 정의 \
 } \
 \
 \


이 구조의 장점은 __데이터의 중첩(Nesting)__ 이 자유롭다는 것입니다. <sup>4</sup>에 따르면 Protobuf는 직렬화/역직렬화 속도가 매우 빠르며, FlatBuffers와 달리 가변 객체(Mutable)로 사용하기 용이하여 아이템 수정이 빈번한 RPG 로직에 적합합니다.<sup>12</sup>

__3.2 Gradle 환경에서의 라이브러리 셰이딩(Shading)__

Spigot 플러그인과 Fabric 모드 모두에서 Protobuf를 사용하려면, 라이브러리 충돌을 방지하기 위해 __Shadow Plugin__을 사용하여 라이브러리를 플러그인 JAR 내부에 포함(Shading)시키고 패키지 경로를 재배치(Relocation)해야 합니다.<sup>14</sup>

__서버 및 클라이언트 build.gradle 설정 예시:__

 

Groovy

 

plugins { \
     id 'com.github.johnrengelman.shadow' version '7.1.2' \
     id 'java' \
 } \
 \
 dependencies { \
     implementation 'com.google.protobuf:protobuf-java:3.21.12' \
 } \
 \
 shadowJar { \
     // 패키지 재배치: 다른 플러그인과의 충돌 방지 \
     relocate 'com.google.protobuf', 'com.rpgserver.libs.protobuf' \
     archiveClassifier.set('') \
 } \
 \
 tasks.build.dependsOn tasks.shadowJar \
 \
 \


이 설정은 com.google.protobuf 패키지를 com.rpgserver.libs.protobuf로 컴파일 타임에 변경하여, 서버에 설치된 다른 플러그인이 다른 버전의 Protobuf를 사용하더라도 충돌이 발생하지 않도록 보장합니다.<sup>16</sup>


---

__4. 서버 엔지니어링: Lua 스크립팅 및 MythicMobs 연동__

서버의 핵심 역할은 게임 로직의 연산입니다. 그러나 자바(Java)로 모든 콘텐츠(스킬, 아이템 효과, 드롭 테이블)를 하드코딩하면 기획자가 밸런스를 수정할 때마다 서버를 재시작해야 하는 비효율이 발생합니다. 이를 해결하기 위해 __Lua 스크립팅 엔진__을 도입하여 콘텐츠 로직과 엔진 로직을 분리합니다.

__4.1 Lua 스크립팅 엔진 구축__

__LuaInMinecraftBukkit II__는 Spigot 환경에서 Lua 5.3/5.4를 지원하며, 멀티스레딩 처리가 가능하여 고성능 연산이 필요한 RPG 서버에 최적화되어 있습니다.<sup>2</sup>

__4.1.1 Java-Lua 브릿지(Bridge) 구현__

보안과 편의성을 위해 Bukkit API를 직접 노출하기보다는, 래퍼(Wrapper) 클래스를 통해 제한된 기능만 Lua에 제공해야 합니다.

__Java 측 API (Wrapper):__

 

Java

 

public class RpgPlayerWrapper { \
     private final Player player; \
     private final PlayerData rpgData; \
 \
     public RpgPlayerWrapper(Player player) { \
         this.player = player; \
         this.rpgData = Database.get(player.getUniqueId()); \
     } \
 \
     public void addMana(double amount) { \
         rpgData.setMana(rpgData.getMana() + amount); \
         // 클라이언트에 마나 업데이트 패킷 전송 로직 포함 \
     } \
 \
     public void playEffect(String effectName) { \
         // ParticleLib 등을 이용한 효과 재생 \
     } \
 } \
 \
 \


__Lua 스크립트 예시 (아이템 발동 효과):__

 

Lua

 

-- scripts/items/legendary_sword.lua \
 function onAttack(attacker, victim) \
     local rpgAttacker = RpgAPI.getPlayer(attacker) \
     if rpgAttacker:getMana() > 10 then \
         rpgAttacker:addMana(-10) \
         victim:setFireTicks(100) \
         rpgAttacker:playEffect("FLAME_BURST") \
         return true -- 효과 발동 성공 \
     end \
     return false \
 end \
 \
 \


이러한 구조는 RpgAPI라는 전역 객체를 통해 Lua 스크립트가 안전하게 서버의 기능을 호출할 수 있게 합니다.<sup>2</sup>

__4.2 MythicMobs와 Lua의 통합 (Custom Mechanics)__

MythicMobs는 강력한 몹 생성 도구이지만, 복잡한 커스텀 AI나 조건부 스킬을 구현하기에는 YAML 설정만으로는 한계가 있습니다. MythicMobs의 API를 활용하여 __Custom Mechanic__을 등록하고, 이를 통해 Lua 스크립트를 호출하는 방식을 제안합니다.

__4.2.1 Custom Mechanic 등록 (Java)__

<sup>11</sup>에 따라 ISkillMechanic 인터페이스를 구현하여 새로운 스킬 타입을 등록합니다.

 

Java

 

public class LuaSkillMechanic implements ISkillMechanic { \
     private String scriptFile; \
     private String functionName; \
 \
     public LuaSkillMechanic(MythicLineConfig config) { \
         this.scriptFile = config.getString(new String{"script", "s"}); \
         this.functionName = config.getString(new String{"function", "f"}); \
     } \
 \
     @Override \
     public boolean cast(SkillMetadata data) { \
         // Lua 엔진에 해당 스크립트의 함수 실행 요청 \
         return LuaEngineManager.execute(scriptFile, functionName, data.getCaster(), data.getTrigger()); \
     } \
 } \
 \
 \


__4.2.2 MythicMobs 설정 적용 (YAML)__

이제 몹 설정 파일에서 lua 메카닉을 사용할 수 있습니다.

 

YAML

 

Boss_FireLord: \
   Type: WITHER_SKELETON \
   Display: '&c화염 군주' \
   Health: 5000 \
   Skills: \
   - lua{s=boss_ai; f=check_phase_transition} @Self ~onTimer:20 \
   - lua{s=boss_skills; f=meteor_storm} @TargetLocation ~onSignal:CAST_METEOR \
 \
 \


이 방식은 <sup>10</sup>에서 언급된 몹 속성 제어와 <sup>20</sup>의 커스텀 스킬 시스템을 결합하여, 기획자가 Lua만으로 보스 패턴을 무한히 확장할 수 있게 합니다.


---

__5. 클라이언트 모드 개발: Fabric & 디아블로 UI__

서버가 데이터를 보냈을 때, 이를 시각적으로 표현하는 것은 클라이언트의 몫입니다. Fabric 모드 로더와 __oωo-lib__을 사용하여 바닐라 인벤토리를 완전히 대체하는 커스텀 GUI를 구현합니다.

__5.1 그리드 기반 인벤토리 시스템 구현__

디아블로 스타일 인벤토리의 핵심은 '테트리스' 방식의 아이템 배치입니다. 이는 바닐라 마인크래프트의 Slot 시스템(1칸=1아이템)과는 근본적으로 다르므로, ScreenHandler와 HandledScreen을 재정의해야 합니다.<sup>21</sup>

__5.1.1 가상 인벤토리 알고리즘 (Rectangular Packer)__

클라이언트와 서버 모두 아이템이 그리드 내에 배치될 수 있는지 검증하는 알고리즘이 필요합니다.<sup>23</sup>



* __데이터 구조:__ boolean[width][height] 형태의 2차원 배열로 그리드 점유 상태를 관리합니다.
* __배치 검증 로직:__
1. 아이템 A (크기 2x3)를 (x, y)에 놓으려 함.
2. grid[x][y]부터 grid[x+1][y+2]까지의 셀이 모두 false(비어있음)인지 확인.
3. 모두 비어있다면 배치 후 해당 셀들을 true로 변경.
4. 하나라도 차 있다면 배치 불가(충돌).

__5.1.2 oωo-lib을 이용한 UI 렌더링__

oωo-lib은 계층형 UI 구조를 지원하여 복잡한 GUI를 쉽게 구성할 수 있습니다.<sup>8</sup>

__UI 컴포넌트 설계:__



1. __RootContainer:__ 화면 전체를 덮는 베이스 컨테이너.
2. __GridPanel:__ 인벤토리 그리드 배경 텍스처를 렌더링하고, 마우스 이벤트를 캡처하여 그리드 좌표 (grid_x, grid_y)로 변환.
3. __ItemComponent:__ 각 아이템을 렌더링하는 컴포넌트. Protobuf로 수신한 RpgItem 데이터를 기반으로 아이콘을 그림.

3D 모델 렌더링 통합:

단순한 2D 아이콘 대신, 인벤토리 내에서 아이템이 3D 모델로 회전하며 보이도록 구현합니다. Fabric의 DrawContext와 BakedModel을 활용합니다.25

 

Java

 

// Fabric Client Side Rendering Code Snippet \
 public void renderItem3D(DrawContext context, int x, int y, RpgItem item) { \
     MatrixStack matrices = context.getMatrices(); \
     matrices.push(); \
     matrices.translate(x + 8, y + 8, 100); // 슬롯 중심으로 이동 \
     matrices.scale(16f, -16f, 16f); // 크기 조정 및 Y축 반전 \
     matrices.multiply(RotationAxis.POSITIVE_Y.rotationDegrees((System.currentTimeMillis() % 3600) / 10f)); // 회전 애니메이션 \
     \
     // 리소스 팩에서 모델 로드 및 렌더링 \
     BakedModel model = MinecraftClient.getInstance().getItemRenderer().getModels().getModel(item.getItemStack()); \
     VertexConsumerProvider.Immediate vertexConsumers = context.getVertexConsumers(); \
     \
     // 조명 효과 적용하여 렌더링 \
     MinecraftClient.getInstance().getItemRenderer().renderItem( \
         item.getItemStack(), \
         ModelTransformationMode.GUI, \
         false, \
         matrices, \
         vertexConsumers, \
         LightmapTextureManager.MAX_LIGHT_COORDINATE, \
         OverlayTexture.DEFAULT_UV, \
         model \
     ); \
     \
     matrices.pop(); \
 } \
 \
 \


이 코드는 인벤토리 GUI 내에서 실제 게임 내 엔티티처럼 아이템을 3D로 렌더링하여 디아블로와 같은 고급스러운 시각 효과를 제공합니다.


---

__6. 네트워킹 및 통신 파이프라인__

Protobuf로 정의된 데이터를 실제 네트워크로 전송하기 위해서는 안정적인 패킷 파이프라인이 필요합니다.

__6.1 ProtocolLib과 Netty 채널__

서버 측에서는 __ProtocolLib__을 사용하여 패킷을 가로채고 조작하는 것이 가장 안정적입니다.<sup>27</sup> 직접 NMS(net.minecraft.server)를 건드리는 것은 마인크래프트 버전 업데이트 시마다 코드가 깨질 위험이 큽니다.



* __채널 등록:__ rpg:network라는 이름의 커스텀 채널을 등록합니다.<sup>29</sup>
* __패킷 흐름:__
1. __서버:__ 아이템 변경 발생 -> Protobuf 직렬화 -> byte 생성 -> PacketPlayOutCustomPayload 생성 -> 전송.
2. __클라이언트 (Fabric):__ ClientPlayNetworking.registerGlobalReceiver를 통해 rpg:network 채널 수신 -> Protobuf 역직렬화 -> 클라이언트 데이터 모델 업데이트 -> UI 갱신.<sup>30</sup>

__6.2 낙관적 업데이트 (Optimistic Updates)__

네트워크 지연(Latency)으로 인한 UI 반응성 저하를 막기 위해 클라이언트는 낙관적 업데이트를 수행해야 합니다.



1. 플레이어가 아이템을 이동시키면, 클라이언트는 서버의 응답을 기다리지 않고 __즉시 UI상에서 아이템을 이동__시킵니다.
2. 동시에 서버로 이동 패킷을 전송합니다.
3. 서버에서 검증 실패 시(예: 이미 해당 위치에 아이템이 생성됨), 롤백 패킷을 보내 클라이언트의 아이템을 원래 위치로 되돌립니다. \
 이는 디아블로와 같은 빠른 템포의 게임에서 필수적인 UX 요소입니다.


---

__7. 리소스 및 모델 구현 (Resource/Model)__

커스텀 아이템과 몹의 외형은 리소스 팩과 클라이언트 모드의 협업으로 완성됩니다.

__7.1 CustomModelData와 ModelEngine__

서버 리소스 팩의 CustomModelData 기능을 활용하여 바닐라 아이템(예: 철검)에 수천 개의 다른 텍스처/모델을 할당할 수 있습니다.



* __ModelEngine 4 (서버):__ 몹의 뼈대(Bone) 애니메이션을 처리합니다.<sup>31</sup>
* __AzureLib (클라이언트):__ Fabric 모드에서 복잡한 애니메이션을 렌더링할 때 사용합니다.<sup>33</sup>

특히, 전설 아이템 드롭 시 디아블로처럼 땅에서 빛기둥(Light Pillar)이 솟아오르는 효과는 클라이언트 모드에서 WorldRenderEvents를 믹스인(Mixin)하여, 특정 NBT 태그(예: tier: legendary)를 가진 아이템 엔티티 위에 쉐이더 효과를 렌더링함으로써 구현합니다.<sup>35</sup>


---

__8. 최종 구현 로드맵 및 결론__

본 계획서에 따른 개발 단계는 다음과 같습니다.

__단계별 개발 계획__

 


<table>
  <tr>
   <td><strong>단계</strong>
   </td>
   <td><strong>주요 작업 내용</strong>
   </td>
   <td><strong>사용 기술 및 도구</strong>
   </td>
  </tr>
  <tr>
   <td><strong>Phase 1</strong>
   </td>
   <td><strong>기반 구축</strong>
   </td>
   <td>Protobuf 스키마 정의 및 컴파일, Gradle 멀티 모듈 프로젝트 설정, 라이브러리 셰이딩 설정.
   </td>
  </tr>
  <tr>
   <td><strong>Phase 2</strong>
   </td>
   <td><strong>서버 코어 개발</strong>
   </td>
   <td>LuaInMinecraftBukkit II 연동, RpgAPI Java 래퍼 작성, DB 연동(PostgreSQL), ProtocolLib 패킷 리스너 구현.
   </td>
  </tr>
  <tr>
   <td><strong>Phase 3</strong>
   </td>
   <td><strong>클라이언트 UI 개발</strong>
   </td>
   <td>Fabric 모드 기본 골격 생성, oωo-lib 기반 그리드 인벤토리 UI 구현, 아이템 3D 렌더러 작성.
   </td>
  </tr>
  <tr>
   <td><strong>Phase 4</strong>
   </td>
   <td><strong>콘텐츠 통합</strong>
   </td>
   <td>MythicMobs 커스텀 메카닉(Lua 연동) 구현, 테스트 몹 및 아이템 제작, 리소스 팩 적용.
   </td>
  </tr>
  <tr>
   <td><strong>Phase 5</strong>
   </td>
   <td><strong>최적화 및 배포</strong>
   </td>
   <td>네트워크 패킷 압축 최적화, 스파크(Spark)를 이용한 성능 프로파일링 <sup>1</sup>, 클라이언트 배포 파이프라인 구축.
   </td>
  </tr>
</table>


__결론__

본 보고서에서 제안하는 시스템은 마인크래프트의 한계를 기술적으로 극복하여 AAA급 RPG 경험을 제공하는 것을 목표로 합니다. __Protobuf__를 통한 고효율 데이터 통신, __Lua__를 통한 유연한 콘텐츠 관리, 그리고 __Fabric & oωo-lib__을 통한 독자적인 UI 경험은 기존 서버들과 차별화된 핵심 경쟁력이 될 것입니다. 이 아키텍처는 초기 구축 난이도가 높으나, 장기적으로 유지보수가 용이하고 콘텐츠 확장이 무한한 확장성을 제공합니다.


---

__부록: 예상되는 기술적 문제 및 해결 방안 (Troubleshooting)__



1. __Packet Handling Error (버전 불일치):__ 서버와 클라이언트의 모드 버전이 다를 경우 접속 시 넷티(Netty) 에러가 발생할 수 있습니다.<sup>36</sup>
* _해결:_ 접속 핸드쉐이크 단계에서 커스텀 패킷으로 버전을 확인하고, 불일치 시 사용자에게 업데이트 안내 GUI를 띄우도록 클라이언트 모드 진입점을 설계해야 합니다.<sup>37</sup>

2.              __리소스 팩 보안:__ 클라이언트에 다운로드된 리소스 팩은 추출되기 쉽습니다.



* _해결:_ 중요한 로직(드롭 확률, 데미지 공식)은 절대 클라이언트에 전송하지 않고 서버 Lua 스크립트로만 처리하여 보안을 유지합니다. 3D 모델 파일은 암호화하기 어려우므로, 저작권 고지를 명확히 하는 정책적 접근이 필요합니다.
